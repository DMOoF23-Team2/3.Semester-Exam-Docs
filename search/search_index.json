{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Denne side fungerer som dokumentation for Rally Lydighedsprojekt <code>(Rally Obedience)</code>. Dette projekt er Team 2's 3. semesters eksamensprojekt ved datamatiker online uddannelsen p\u00e5 UCL.</p>"},{"location":"#fag","title":"Fag","text":"<p>Projektet udarbejdes med baggrund i 3 fag. Hvordan hvert fags emner anvendes i projektet er dokumenteret og kan ses ved at klikke p\u00e5 nedenst\u00e5ende fag.</p> <ul> <li>Systemudvikling</li> <li>Programmering</li> <li>Teknologi</li> </ul>"},{"location":"#lringsmal","title":"L\u00e6ringsm\u00e5l","text":""},{"location":"#systemudvikling","title":"Systemudvikling","text":"<ul> <li>Viden<ul> <li>udviklingsbaseret viden om systemudviklingsmetoder og processers betydning for kvalitet i produkt og proces</li> </ul> </li> <li>F\u00e6rdigheder<ul> <li>anvende en valgt systemudviklingsmetode og arbejde systematisk med et praksisn\u00e6rt projekt ved brug af denne.</li> <li>anvende centrle principper til at udarbejde projektplaner samt vurdere og regulere dem hensigtsm\u00e6ssigt.</li> <li>vurdere praksisn\u00e6re problemstillinger og situationsbestemt v\u00e6lge en procesmodel og systemudviklingsmetode.</li> <li>formidle systemudviklingens proces og produkt til samarbejdspartnere og brugere.</li> </ul> </li> <li>Kompetencer<ul> <li>h\u00e5ndtere situationsbestemt tilpasning af systemudviklingsmetoder og processer til et konkret praksisn\u00e6rt projekt</li> <li>deltage kompetent i et fagligt og tv\u00e6rfagligt systmudviklingsprojekt med tilpassede metoder.</li> <li>i en struktureret sammenh\u00e6ng tilegne sig ny viden om procesmodeller og systemudvkilingsmetoder.</li> </ul> </li> </ul>"},{"location":"#programmering","title":"Programmering","text":"<ul> <li>Viden<ul> <li>udviklingsbaseret viden om integration mellem heterogene komponenter og platforme.</li> <li>forst\u00e5else for teori og praksis vedr\u00f8rende distribueret programmering.</li> </ul> </li> <li>F\u00e6rdigheder<ul> <li>anvende centrale teknikker til at designe og konstruere programmer med flere samtidige brugere baseret p\u00e5 samarbejdende processer i en distribueret arkitektur.</li> <li>anvende designm\u00f8nstre for distribuerede softwarearkitektur til at konstruere programmer der benytter tidssvarende netv\u00e6rkstekonologier.</li> <li>anvende centrale metoder og redskaber til at udvikle softwarekomponenter og webaplikationer.</li> <li>vurdere kvalitative konsekvenser af et l\u00f8sningsforslag.</li> </ul> </li> <li>Kompetencer<ul> <li>h\u00e5ndtere arbejdet som en professionel programm\u00f8r i integrationsprojekter.</li> <li>deltage aktivt i st\u00f8rre programmeringsprojekter.</li> <li>i en struktureret sammenh\u00e6ng tilegne sig ny viden, f\u00e6rdigheder og kompetencer inden for programmeringssprog, udviklingsv\u00e6rkt\u00f8jer, programmeringsteknikker og programdesign.</li> </ul> </li> </ul>"},{"location":"#teknologi","title":"Teknologi","text":"<ul> <li>Viden<ul> <li>udviklingsbaseret viden om praksis og centralt anvendt teori inden for design og realisering af distribuerede systemer.</li> <li>forst\u00e5else for fundamentale netv\u00e6rksbegreber</li> </ul> </li> <li>F\u00e6rdigheder<ul> <li>anvende centrale redskaber til virtualisering.</li> <li>anvende centrale og i praksis udbredte applikationsprotokoller.</li> <li>vurdere praksisn\u00e6re problemstillinger vedr\u00f8rende centrale sikkerhedsm\u00e6ssige begreber og trusler.</li> <li>vurdere relevante teknologiske aspekter i udviklingen af distribuerede systemer.</li> </ul> </li> <li>Kompetencer<ul> <li>Varetage valg af infrastruktur i forbindelse med udvikling af distribuerede systemer.</li> <li>I en struktureret sammenh\u00e6ng tilegne sig ny viden, f\u00e6rdigheder indenfor distribuerede systemer.</li> </ul> </li> </ul>"},{"location":"#rammen-for-projekt-rally-lydighed","title":"Rammen for Projekt Rally Lydighed","text":"<p>Projektet har til form\u00e5l, at give de studerende et praktisk erfraingsgrundlag med de gennemg\u00e5ede emner p\u00e5 3. semester. projektet vil blive brugt som grundlag for eksamen p\u00e5 3. semester.</p>"},{"location":"#product-owner-po","title":"Product Owner (PO)","text":"<p>PO er underviseren Lene.  PO er instrukt\u00f8r i <code>rally lydighed</code>, som er en hundesport, i sin fritid. PO er tilknyttet <code>Nordfyns Civile Hundef\u00f8rerforening (NcH)</code>, som projektet udarbejdes for/til.</p> <p>Undervejs i projektets levetid, har Team 2 mulighed for at booke m\u00f8der med PO. Disse m\u00f8der anvendes til at pr\u00e6sentere udarbejdet materiale hvis relevant for PO, samt afklaring af sp\u00f8rgsm\u00e5l, krav, prioriteringer mm.</p>"},{"location":"Scope/","title":"Project Scope","text":""},{"location":"Scope/#projektets-overordnede-mal","title":"Projektets overordnede m\u00e5l","text":"<ul> <li>Udvikle en platform til NcH.</li> <li>Platformen skal optimere arbejdsprocesserne ved udarbejdelsen af baner til tr\u00e6ning.</li> <li>Platformen skal give mulighed for at instrukt\u00f8rer kan samarbejde om bane design og dele udf\u00e6rdige baner med hinanden.</li> <li>Platformen skal give mulighed for at instrukt\u00f8rer kan kommentere p\u00e5 baner der er delt med dem.</li> <li>Platformen skal fungere som prim\u00e6r kommunikationskanal og give instrukt\u00f8rerne mulighed for at kommunikere internt og med deres tr\u00e6ningshold.</li> </ul>"},{"location":"Scope/#ngleinteressenter","title":"N\u00f8gleinteressenter","text":"<ul> <li> <p>Nordfyns Civile Hundef\u00f8rerforening (NcH): NcH er den prim\u00e6re bruger og modtager af platformen. De vil bruge platformen til at designe og dele tr\u00e6ningsbaner, samt til at kommunikere internt og med deres tr\u00e6ningshold. Deres feedback og behov vil v\u00e6re afg\u00f8rende for platformens design og funktionalitet.</p> </li> <li> <p>Instrukt\u00f8rer: Instrukt\u00f8rerne er de prim\u00e6re brugere af platformen. De vil bruge platformen til at designe tr\u00e6ningsbaner, og samarbejde med andre instrukt\u00f8rer. Deres brugeroplevelse og tilfredshed er afg\u00f8rende for platformens succes.</p> </li> </ul>"},{"location":"Scope/#projektmal-for-udviklingsteamet","title":"Projektm\u00e5l for udviklingsteamet","text":"<ul> <li>Implementer \u201cRealTime\u201d samarbejdsfunktioner, s\u00e5 instrukt\u00f8rer kan arbejde simultant p\u00e5 samme bane.</li> <li>Udvikle en brugervenlig gr\u00e6nseflade, der tillader let design af baner med tr\u00e6k og slip funktionalitet.</li> <li>Integrere regel validering for banedesign, der automatisk kontrollerer overensstemmelse med g\u00e6ldende regler og standarder for de forskellige klasser ved konkurrencebaner.</li> <li>Opret en database til lagring af baner, s\u00e5 brugere kan gemme og genbruge deres designs</li> <li>Implementer brugeradgangskontrol, der giver ejerne af banen mulighed for at dele med udvalgte brugere.</li> <li>Udvikle en kommentar funktion, der muligg\u00f8r feedback og diskussion mellem brugere p\u00e5 designet bane.</li> <li>Udvikle et besked-/notifikationssystem, der giver instrukt\u00f8rer mulighed for at modtage og svare p\u00e5 vigtige meddelelser fra andre instrukt\u00f8rer.</li> <li>Skab mulighed for oprettelse af grupper eller teams, s\u00e5 instrukt\u00f8rer kan organisere sig og kommunikere med hinanden.</li> </ul>"},{"location":"Scope/#prioriteret-feature-list","title":"Prioriteret Feature List","text":"<p>Her finde du den prioriteret Feature list</p>"},{"location":"Scope/#tidsramme-og-mileple","title":"Tidsramme og Milep\u00e6le","text":"<p>Projektet igangsat d. 12. feb. 2024.  forventet slutdato er d. 15 maj. 2024.</p> <ul> <li>Milep\u00e6l 1 (efter 2 uger): Overordnet model designet</li> <li>Milep\u00e6l 2 (efter 3 uger): Overordnet model og CRUD funktionalitet implementeret</li> <li>Milep\u00e6l 3 (efter 5 uger): - bestemmes ud fra features fra feature list</li> <li>Milep\u00e6l 4 (efter 7 uger): - bestemmes ud fra features fra feature list</li> <li>Milep\u00e6l 5 (efter 9 uger): - bestemmes ud fra features fra feature list</li> <li>Milep\u00e6l 6 (efter 13 uger): Fejlrettelse og f\u00e6rdigg\u00f8relse.</li> </ul>"},{"location":"Scope/#teknologisk-stak","title":"Teknologisk Stak","text":"<p>Platformen vil blive udviklet som en webapplikation ved brug af f\u00f8lgende teknologier:</p> <ul> <li>Front-end: Blazor vil blive brugt til at skabe en dynamisk og interaktiv brugergr\u00e6nseflade.</li> <li>Back-end: ASP.NET med C# vil blive brugt i en objektorienteret, lagdelt arkitektur. Dette vil h\u00e5ndtere server-side logik og kommunikation med databasen.</li> <li>Database: SQL Server Management Studio (SSMS) vil blive brugt til robust og effektiv dataopbevaring.</li> </ul> <p>Disse teknologier vil arbejde sammen for at danne et distribueret system, der sikrer en modul\u00e6r og fremtidssikret l\u00f8sning. Dette vil g\u00f8re det muligt at udvide med yderligere funktionalitet og let vedligeholde systemet.</p> <ul> <li>Hosting: Vi vil bruge Microsoft Azure til at hoste vores webapplikation. Azure tilbyder p\u00e5lidelig og skalerbar cloud hosting med h\u00f8j tilg\u00e6ngelighed.</li> <li>Sikkerhed: Vi vil implementere sikkerhedsforanstaltninger p\u00e5 flere niveauer. Dette inkluderer HTTPS for sikker dataoverf\u00f8rsel, brug af sikre password hashing algoritmer til opbevaring af brugerpasswords, og brug af JWT (JSON Web Tokens) til sikker brugerautorisering og -autentificering.</li> </ul>"},{"location":"Scope/#teststrategi-og-kvalitetskontrol","title":"Teststrategi og Kvalitetskontrol","text":"<p>For at sikre kvalitet og fejlfri ydeevne i vores projekt, vil vi anvende en kombination af forskellige testmetoder:</p> <ul> <li> <p>Unit Tests: Vi vil bruge MSTest frameworket til at skrive unit tests for vores kode. Dette vil hj\u00e6lpe os med at identificere og rette fejl p\u00e5 et tidligt tidspunkt i udviklingsprocessen. Vi vil str\u00e6be efter at have en h\u00f8j testd\u00e6kning for at sikre, at alle dele af vores kode fungerer som forventet. </p> </li> <li> <p>Integration Tests: Vi vil skrive integration tests for at teste, hvordan forskellige dele af vores system fungerer sammen. Dette vil hj\u00e6lpe os med at identificere eventuelle problemer, der kan opst\u00e5, n\u00e5r forskellige dele af systemet interagerer.</p> </li> <li> <p>Acceptance Tests: Vi vil arbejde t\u00e6t sammen med vores Product Owner (PO) for at definere og udf\u00f8re acceptance tests. Disse tests vil sikre, at systemet opfylder de forventede krav og fungerer som forventet i et realistisk milj\u00f8.</p> </li> <li> <p>Code Reviews: Vi vil regelm\u00e6ssigt gennemf\u00f8re code reviews for at sikre, at vores kode overholder de bedste praksis for kodning og design. Dette vil ogs\u00e5 give os mulighed for at l\u00e6re af hinanden og forbedre vores kodningsevner.</p> </li> <li> <p>M\u00f8der med Product Owner (PO): Vi vil have regelm\u00e6ssige m\u00f8der med vores PO (mindst en gang om m\u00e5neden) for at diskutere projektets fremskridt, afklare eventuelle tvivlssp\u00f8rgsm\u00e5l og modtage feedback. Dette vil hj\u00e6lpe os med at sikre, at vi er p\u00e5 rette vej og opfylder PO's forventninger.</p> </li> </ul> <p>Ved at f\u00f8lge denne teststrategi og fokusere p\u00e5 kvalitetskontrol, str\u00e6ber vi efter at udvikle et h\u00f8jkvalitetsprodukt, der opfylder vores kunders behov og forventninger.</p>"},{"location":"extreamProgramming/","title":"Extream Programming","text":""},{"location":"extreamProgramming/#foranalyse-analyse-af-projektets-situation-projektstyring","title":"Foranalyse / analyse af projektets situation / Projektstyring","text":"<p>Som en del af den l\u00f8bende analyse af projektets situation, er f\u00f8lgende <code>Usikkerheder</code> og <code>Kompleksiteter</code> identificeret p\u00e5 nuv\u00e6rende tidspunkt i projektet.</p> <ul> <li>Projektet skal kunne h\u00e5ndtere flere brugere p\u00e5 en gang, tilt\u00e6nkt teknologi til at l\u00f8se dette i forbindelse med <code>live-shar af bane</code> er <code>SingalR</code>. Da udviklings teamet aldrig har arbejdet med singnalR f\u00f8r, er deres viden omkring implementering af dette ikke eksisterende og skal tilegnes undervejs.</li> <li>Projektet sjal have et login-system / funktionalitet, dette er p\u00e5 nuv\u00e6rende tidspunkt implementeret, s\u00e5ledes, at <code>data-laget</code> anvender <code>AspNetCore.Identity</code> og <code>AspNetCore.Identity.EntityFramworkCore</code>. Igen er udviklingsteamets viden begr\u00e6nset da de ikke har arbejdet med login f\u00f8r. Derfor skal viden omkring implementeringen af dette tilegnes undervejs.</li> <li>projektets <code>front-end</code> del udvikles i <code>Blazor</code>. Igen er der f\u00f8rste gang udviklingsteamet arbejder med Blazor og dermed endnu en ny teknologi, hvor viden skal tilegnes undervejs.</li> <li>projektet skal v\u00e6re et <code>distribueret-system</code>, da dette projekt er f\u00f8rste gang udviklings teamets arbejder med distribueret systemer, skal viden om arkitekturen og ansvarsfordeling for de kommende sub systemer tilegnes undervejs.</li> </ul>"},{"location":"extreamProgramming/#usikkerheder","title":"Usikkerheder","text":"<ul> <li>Teknologier<ul> <li>SignalR<ul> <li>Hvad er signalR? - WebSocket</li> <li>Hvordan implementeres signalR?</li> <li>I hvilken kontekst anvendes signalR? - real-time web funktionaliteter</li> </ul> </li> <li>Identity on ASP.NET Core<ul> <li>Hvad er Identity? - Anvendes til login funktionaliteter</li> <li>Hvor i den distribuerede arkitektur skal Identity implementeres? (Blazor, API eller Data - solution? er det et samspil imellem lagene).</li> </ul> </li> <li>JSON web Tokens - JWT<ul> <li>Hvordan sikres API'et bedst? - ved en token pr. user? eller andet ?</li> <li>Hvordan kan JWT og Identity h\u00e6nge sammen</li> </ul> </li> <li>Blazor<ul> <li>Hvad er Blazor?</li> <li>Hosting og kommunikation med API ?</li> </ul> </li> </ul> </li> </ul>"},{"location":"extreamProgramming/#uklare-krav","title":"Uklare Krav","text":"<ul> <li>Hvilket <code>roller</code> skal have adgang til hvilket funktionaliteter?</li> <li>Skal der v\u00e6re en Admin rolle og hvad skal denne anvendes til`<ul> <li>Tilf\u00f8je nye useres?</li> <li>Tildele roller til eksisterende users?</li> <li>Gendannelse af baner hvis de bliver slettet ved et uheld?</li> </ul> </li> </ul>"},{"location":"extreamProgramming/#kompleksiteter","title":"Kompleksiteter","text":"<ul> <li>Flere brugere<ul> <li>Forskellige roller</li> <li>Forskellig brug og form\u00e5l med systemet</li> <li>mange scenarier der ber\u00f8r klasserne <code>Course</code> og <code>User</code></li> </ul> </li> <li>Integrationer/hosting<ul> <li>Kommunikation mellem<ul> <li>Data-solution - Skolens VPN og server</li> <li>API - Azure (brugen af JWT)</li> <li>Blazor - ??</li> </ul> </li> </ul> </li> </ul>"},{"location":"extreamProgramming/#samlet-vurdering-af-usikkerheder-og-kompleksiteter","title":"Samlet vurdering af Usikkerheder og Kompleksiteter","text":"<p>Projektet befinder sig i en situation hvor der er <code>h\u00f8j-usikkerhed</code> og <code>mellem til h\u00f8j - kompleksitet</code>.</p>"},{"location":"extreamProgramming/#valg-af-procesmodel","title":"Valg af procesmodel","text":"<p>P\u00e5 baggrund af analysen af projektets situation v\u00e6lges Cyklisk-Inkrementel Derudover egner Cyklisk-inkrementel sig godt til refaktorering af eksisterende implementeringer.</p> <p>Valget af procesmodel handler om at afd\u00e6kke behovet for at kunne h\u00e5ndtere de usikkerheder og kompleksiteter, der er i vores projekt. Sagt p\u00e5 en anden m\u00e5de, handler valget af procesmodel om at facilitere de bedste rammer for risikostyring. Nedenst\u00e5ende tabel viser ud fra en \u201dtommelfinger-regle\u201d hver af procesmodellerne og hvilket omfang af hhv. kompleksitet og usikkerheder de er egnet til at h\u00e5ndtere.</p> Procesmodel Kompleksitet Usikkerheder Klassisk vandfald Lav Lav Vandfald med overlap eller feedback Mellem Lav Inkrementel vandfald H\u00f8j Lav Cyklisk inkrementel Mellem Mellem-H\u00f8j Iterativ Lav-mellem Mellem-H\u00f8j Agil Lav H\u00f8j SOS H\u00f8j H\u00f8j"},{"location":"extreamProgramming/#valg-af-systemudviklingsmetode","title":"Valg af systemudviklingsmetode","text":"<p>Extrem Programming - XP</p> <p>Da der er identificeret flere problemer/fejl/kommende \u00e6ndringer til den eksisterende implementering fra FDD og i samspil med projektets situation, vurderes en TDD-tilgang passende (test-driven-development). Derudover fokusere XP p\u00e5 at udvikle en ting af gangen til full-fidelity og omfavner \u00e6ndringer, som h\u00e5ndteres inden n\u00e6ste nye ting p\u00e5begyndes.</p> <p>Der vurderes en god sammenh\u00e6ng mellem Cyklisk-inkrementel og XP.</p>"},{"location":"extreamProgramming/#planlgning","title":"Planl\u00e6gning","text":"<p>Prioriteret plan:</p> <ul> <li>CreateCourse - refactor</li> <li>CreateCourseByRegulations - refactor</li> <li>ShareCourse - refactor</li> <li>CollaborationOnCourse - new</li> <li>CommentCourse - new</li> <li>Chat - new</li> </ul> <p>Github Kanban, RoadMap med milep\u00e6le</p>"},{"location":"extreamProgramming/#mileple","title":"Milep\u00e6le","text":"<ul> <li>Estimeret slut = 24-5-2024</li> <li>Milep\u00e6l 5-5-2024 - CreateCours og ShareCourse</li> <li>Milep\u00e6l 12-5-2024 CreateCourseByRegulations - CollaborationOnCourse</li> <li>Milep\u00e6l 19-5-2024 login/Security/deployment/hosting</li> <li>Milep\u00e6l 24-5-2024 Finishing touch ??</li> </ul>"},{"location":"extreamProgramming/#opdateret-dm","title":"Opdateret DM","text":"<p>I forbindelse med skiftet til XP og de mange refatorerings opgavet, har teamet opdateret DM som en del af den l\u00f8bende analyse. Yderligere har teamet valg at nedf\u00e6lde en mere uddybende forklaring af hver <code>konceptuel-klasse</code> for at alle i teamet er <code>attuned</code>. Der kan argumenteres for, at denne uddybende forklaring ogs\u00e5 kan v\u00e6re med til at skabe klarhed om ansvarsfordelingen igennem systemet.</p>"},{"location":"extreamProgramming/#opdateret-dm-xp","title":"Opdateret DM - XP","text":""},{"location":"extreamProgramming/#uddybende-forklaring-af-konceptuelle-klasser","title":"Uddybende forklaring af konceptuelle klasser","text":""},{"location":"extreamProgramming/#tilf\u00f8jelse-ved-xp","title":"Tilf\u00f8jelser i forbindelse med XP","text":"<p>Teamet har tilegnet sig ny viden som projektet er skredet frem og har p\u00e5 baggrund af dette, fors\u00f8gt at identificere nogle <code>abuse-cases</code>. Derudover er en overordnet <code>system-arkitektur</code> opstillet, s\u00e5 TrusselsModellering er muligt. Se ogs\u00e5 risikoanalyse som er den del af trusselsmodellering, for at kunne prioritere de identificerede trsuler / sikkerhedskrav.</p>"},{"location":"extreamProgramming/#abuse-cases","title":"Abuse-cases","text":""},{"location":"extreamProgramming/#overordnet-system-arkitektur","title":"Overordnet system arkitektur","text":"<p>L\u00e6s mere om tankerne bag den overordnede system arkitektur her</p>"},{"location":"featureDrivenDevelopment/","title":"Feature Driven Development","text":""},{"location":"featureDrivenDevelopment/#An-overall-model","title":"An overall model","text":"<p>Her defineres det overodnede <code>scope</code> for <code>Rally Obedience</code> projektet. Dette er b\u00e5de en del a best pratices og Stage 1 n\u00e5r FDD anvendes som systemudviklingsmetode.</p> <p>En systemudviklingsmetode best\u00e5r af en r\u00e6kke sammenh\u00e6ngende teknikker, der hver is\u00e6r udf\u00f8res ved hj\u00e6lp af et eller flere v\u00e6rkt\u00f8jer. En teknik er en generisk beskrivelse af aktiviteter, samt m\u00e5let med denne aktivitet. Et v\u00e6rkt\u00f8j er en specifik angivelse af hvad man vil benytte for at udf\u00f8rer aktiviteten i teknikken. For at sikre sammenh\u00e6ngen mellem teknikkerne i metoden, bliver <code>outputtet</code> fra den ene teknik anvendt som <code>input</code> til den n\u00e6ste teknik.</p> <p>An overall model - som teknik:</p> <ul> <li>Form\u00e5l: <ul> <li>At skabe en f\u00e6llesforst\u00e5else ramme for udviklingsteamet.</li> <li>At skabe en overordnet dom\u00e6ne model.</li> <li>At identificere systemkrav til at skabe en <code>Feature List</code>.</li> <li>At identificere interessenter/<code>stackholders</code>.</li> </ul> </li> <li>V\u00e6rkt\u00f8jer:<ul> <li>Use Cases - <code>UC</code></li> <li>Use Case Diagram - <code>UCD</code></li> <li>Objektmodel - <code>OM</code></li> <li>Dom\u00e6nemodel - <code>DM</code></li> <li>Business Case - <code>BC</code></li> </ul> </li> <li>Output:<ul> <li>Opn\u00e5 viden om emner listet under form\u00e5l</li> <li>At kunne skabe en Feature List n\u00e5r overall model er f\u00e6rdig.</li> </ul> </li> </ul>"},{"location":"featureDrivenDevelopment/#Use-case-fdd","title":"Use Cases - UC","text":"<p>Bane-system</p> <p>Chat-system</p>"},{"location":"featureDrivenDevelopment/#Use-case-diagram-fdd","title":"Use Case Diagram - UCD","text":"<p>Notationsformer i Use Case diagrammet:</p> <ul> <li>Akt\u00f8r - Akt\u00f8rer repr\u00e6senteres med stick-figurer.</li> <li>Use Case - repr\u00f8senteres med ellipser.</li> <li>System Boundary - Systemgr\u00e6nsen er en boks, der omgriveuse cases for at angive systemets omfang.</li> </ul> <p>Relationer mellem Use Cases:</p> <ul> <li>Inklusion - Etiketten <code>&lt;&lt;include&gt;&gt;</code> - Bruges, n\u00e5r en use case inkludere (kalder) en anden use case for at udf\u00f8rer en del af dens funktionalitet. Repr\u00e6senteres med en solid linje med en trekantet pil, der peger mod den inkluderede use case.</li> <li>Udvidelse - Etiketten <code>&lt;&lt;extend&gt;&gt;</code> - Bruges, n\u00e5r en use case kan udvides (optionelt) med ekstra funktionalitet under visse betingelser. Repr\u00e6senteres med en stiplet linje med en \u00e5ben trekantet pil, der peger mod den udvidede use case.</li> <li>Association - Bruges til at vise en almindelig forbindelse eller relation mellem to use cases. Repr\u00e6senteres med en simpel linje uden nogen mark\u00f8rer eller etiketter.</li> </ul> <p>Notation for Pile:</p> <ul> <li>Solid linje - Bruges til at repr\u00e6sentere direktet forbindelser eller inklusioner.</li> <li>Stiplet linje - Bruges til at repr\u00e6sentet valgfri forbindelser eller udvidelser. </li> </ul>"},{"location":"featureDrivenDevelopment/#om-fdd","title":"Objekt Modeller - OM","text":"<p>Som tidligere beskrevet i foranalyse 1 iteration kan systemet deles op i to sub-systemer <code>bane-system</code> og <code>chat-system</code>.</p>"},{"location":"featureDrivenDevelopment/#om-chat-system","title":"OM Chat-system","text":"<p>Nedenst\u00e5ende viser f\u00f8rste iteration af chat-systemets OM. Da selve chat funktionaliteterne ikke har haft s\u00e6rlig h\u00f8j prioritet fra PO's side, se den prioriteret Feature List her. Findes der i skrivende stund (05-05-2024) kun denne udgave af chat-systemets OM.</p>"},{"location":"featureDrivenDevelopment/#om-bane-system","title":"OM Bane-system","text":"<p>Da selve bane funktionaliteterne har haft h\u00f8j prioritet fra PO's side, er der itereraret hen over denne OM i forbindelse med de forskellige sprints udviklingsteamet har haft. Hvor den f\u00f8rste iteration skal ses som v\u00e6rende en del af <code>An overall model</code> og derfor har v\u00e6ret med til at skabe den f\u00e6lles forst\u00e5elsesramme for udviklingsteamet.</p> <p>Se afsnittet Developing by features for hvordan nedenst\u00e5ende OM tilpasse/\u00e6ndres undervejs i udviklingsprocessen.</p>"},{"location":"featureDrivenDevelopment/#1iteration-om-fdd","title":"1. iterations OM Bane-system","text":""},{"location":"featureDrivenDevelopment/#dm-fdd","title":"Dom\u00e6ne Modeller - DM","text":"<p>Ud fra de to OM's er f\u00f8lgende to DM's udf\u00e6rdiget. </p>"},{"location":"featureDrivenDevelopment/#dm-chat-system","title":"DM Chat-system","text":"<p>Som tidligere beskrevet er Chat-systemet ikke videreudviklet under arbejdet med FDD, da disse funktionaliteter har haft lavere prioritet. Derfor er denne DM's form\u00e5l blot at v\u00e6re en del af <code>An-overall-model</code> og den er med til at skabe den f\u00e6lles forst\u00e5elses ramme for udviklingsteamet. Denne DM vil blive refactoreret i en videre udviklingsproces, n\u00e5r udviklingen af chat funktionaliteterne p\u00e5begyndes. </p>"},{"location":"featureDrivenDevelopment/#1-iterations-dm-bane-system","title":"1. iterations DM Bane-system","text":"<p>Denne DM har lige som OM bane-system v\u00e6ret itereraret hen over flere gange i forbindelse med Developing by features. Derfor kan denne <code>1. iterations DM Bane-system</code> ses som v\u00e6rende en del af <code>an-overall-model</code> og den har haft til form\u00e5l at skabe den f\u00e6lles forst\u00e5else ramme for udviklingsteamet inden selve udviklingsprocessen p\u00e5begyndes.</p>"},{"location":"featureDrivenDevelopment/#feature-list","title":"Feature list","text":"<p>Igennem problemstillingen ved BusinessCase er der defineret en r\u00e6kke features, der kan opfylde NcHs behov. P\u00e5 baggrund af denne businesscase, er der udf\u00e6rdiget en r\u00e6kke use cases og deres sammenh\u00e6ng/relationer er defineret og illustreret i use case diagrammet. De definerede features og deres sammenh\u00e6ng illusteret gennem use case og use case diagrammet fungere som hj\u00e6lpende v\u00e6rkt\u00f8jer til at prioritere features. Feature listen er blevet prioriteret p\u00e5 et m\u00f8de med PO. Denne prioriterede feature list vil fungere som udviklingsteamets <code>Backlog</code>.</p> <p>Listen i prioriteret r\u00e6kkef\u00f8lge:</p> Opret tr\u00e6nings bane klik p\u00e5 opret bane --&gt; klik p\u00e5 til tr\u00e6ning --&gt; Feature Viser en tom template. Feature Vise alle skilte og elementer (kegler, pile med betydning som g\u00e5 i ring mm.). Feature Tr\u00e6kke og slippe skilte og andre elementer ind i som udg\u00f8r bane designet. Feature Systemet generer automatisk skilte numre \"p\u00e5 banen\". Feature Systemet genere automatisk en tabel med skilter\u00e6kkef\u00f8lgen og deres ID Feature Systemet generer automatisk pile som viser vejen gennem banen. Opret bane til reglement klik p\u00e5 opret bane --&gt; klik p\u00e5 efter reglement--&gt; V\u00e6lg klasse banen skal v\u00e6re til --&gt; Feature Viser en tom template. Feature Vise alle skilte og elementer (kegler, pile med betydning som g\u00e5 i ring mm.) til den valgte klasse. Feature Systemet validere antal skilte, r\u00e6kkef\u00f8lgen af skilte ift. reglement Feature Systemet generer automatisk skilte numre \"p\u00e5 banen\". Feature Systemet genere automatisk en tabel med skilter\u00e6kkef\u00f8lgen og deres ID Feature Systemet generer automatisk pile som viser vejen gennem banen. Deling af tr\u00e6ningsbane med anden instrukt\u00f8r klik p\u00e5 del bane --&gt; Feature Viser en liste med alle instrukt\u00f8rer Feature Del knap - systemet h\u00e5ndtere/opretter associationer Feature En notifikationer om en bane er blevet del med dig Tilg\u00e5 og kommentere en delt bane klik p\u00e5 baner --&gt; Delte baner Feature Viser en liste med alle baner der er delt med useren (instrukt\u00f8ren). Feature en valgte bane vises. Feature En notifikationer om en bane er blevet del med dig Feature Tilf\u00f8je en kommentar til banen. Feature Vise kommentar historikken i et kommentarspor. Live samarbejde ved oprettelse af tr\u00e6ningsbane Klik p\u00e5 opret bane --&gt; klik p\u00e5 til tr\u00e6ning --&gt; Feature Viser en tom template. Feature Viser alle skilte og elementer (kegler, pile med betydning som g\u00e5 i ring mm.). Feature Viser en \"Live share\" knap. Feature Systemet skal kunne h\u00e5ndtere RealTime samarbejde mellem to users (muligvis gennem et link der bliver delt) Chat mellem to instrukt\u00f8rer Klik p\u00e5 Instrukt\u00f8rer --&gt; V\u00e6lg instrukt\u00f8r --&gt; Klik start chat Feature Liste over instrukt\u00f8r Feature V\u00e6lg start chat med en instrukt\u00f8r Feature Vis tom chat vindue Feature Skriv besked Feature Send besked Feature Chat historik bliver gemt Feature Slet en besked - systemet skal kunne fjerne en besked fra visningen (m\u00e5ske skal den gemmes i en log - sikkerhed). Feature Rediger en besked - systemet skal kunne h\u00e5ndtere at en user \u00f8nsker at redigere i sin egen allerede postede besked. Chat mellem to instrukt\u00f8rer Klik p\u00e5 Instrukt\u00f8rer --&gt; V\u00e6lg instrukt\u00f8r --&gt; Klik start chat Feature Liste over instrukt\u00f8rer Feature V\u00e6lg start chat med en instrukt\u00f8r Feature Vis tom chat vindue Feature Skriv besked Feature Send besked Feature Chat historik bliver gemt Feature Slet en besked - systemet skal kunne fjerne en besked fra visningen (m\u00e5ske skal den gemmes i en log - sikkerhed) Feature Rediger en besked - systemet skal kunne h\u00e5ndtere at en bruger \u00f8nsker at redigere i sin egen allerede postede besked Opret gruppechat for instrukt\u00f8rer Feature Viser en liste med alle instrukt\u00f8rer Feature Systemet tilknytter en bruger til den oprettede gruppe Feature Tilf\u00f8j bruger efter gruppechatten er oprettet Feature Forlad gruppen Feature Slet gruppechat Feature Visning over alle medlemmer af gruppechatten Feature Visning over alle \"mine\" grupper Feature Viser et tekstfelt til oprettelse af besked Feature Send/post besked - systemet gemmer beskeden, s\u00e5 den er synlig for de andre medlemmer af gruppen Feature Systemet viser beskedhistorikken, s\u00e5 der er styr p\u00e5 hvem der skrev hvad hvorn\u00e5r i visningen af alle beskeder Feature Slet en besked - systemet skal kunne fjerne en besked fra visningen (m\u00e5ske skal den gemmes i en log - sikkerhed) Feature Rediger en besked - systemet skal kunne h\u00e5ndtere at en bruger \u00f8nsker at redigere i sin egen allerede postede besked Kommunikation i gruppechat Feature Der skal v\u00e6re et tekstfelt, hvor der kan skrives en besked Feature Der skal v\u00e6re en 'send knap' som sender teksten i tekstfeltet til modtagerne Feature Der skal v\u00e6re en feedback der viser at modtagerne har modtaget beskeden, og n\u00e5r modtagerne har l\u00e6st beskeden Feature Der skal v\u00e6re mulighed for at redigere eller slette en tidligere besked eller tekst Feature Der skal v\u00e6re mulighed for at svare direkte p\u00e5 en besked i chatten Feature Der skal v\u00e6re en visning af hvem der er afsender p\u00e5 de enkelte beskeder Feature Der skal v\u00e6re 'time stamps' p\u00e5 alle de beskeder der bliver sendt"},{"location":"featureDrivenDevelopment/#Developing-by-feature","title":"Developing by features","text":"<p>Den overordnede plan for at f\u00f8lge denne <code>Best pratices in FDD</code> er fors\u00f8gt illustreret p\u00e5 nedenst\u00e5ende billede.</p> <p>Her skal der s\u00e6rligt l\u00e6gges v\u00e6gt p\u00e5 Stages 3-5. Hvor mening var for hver <code>Feature</code> som har en tilh\u00f8rende <code>Use Case</code> skulle der udf\u00e6rdiges </p> <ul> <li>Systemsekvensdiagram - <code>SSD</code></li> <li>Sekvensdiagram - <code>SD</code></li> <li>operationskontrakt - <code>OC</code></li> </ul> <p>se Design by feature for disse artefakter.</p> <p>Dern\u00e6st kunne OM og DM fra <code>An-overall-model</code> opdateres s\u00e5 den f\u00e6lles forst\u00e5elsesramme for udviklingsteamet altid var <code>Aligned</code>.</p> <p>Men som det tydligt fremg\u00e5r af nedenst\u00e5ende artefaktor lykkedes det ikke udviklingsteamet at f\u00f8lge denne plan. Dette vurderes at skyldes <code>Usikkerheder</code> og <code>Kompleksiteter</code> i projektet som udviklingsteamet ikke var opm\u00e6rksomme p\u00e5 ved opstarten af projektet og valget af FDD. L\u00e6s mere om dette i refleksionsafsnittet her.</p>"},{"location":"featureDrivenDevelopment/#2-iterations-om-og-dm-bane-system","title":"2. iterations OM og DM Bane-system","text":""},{"location":"featureDrivenDevelopment/#3-iterations-dm-bane-system","title":"3. iterations DM Bane-system","text":""},{"location":"featureDrivenDevelopment/#Component-class-ownership","title":"Component/Class ownership","text":"<p>N\u00e5r GitHub Projects anvendes, kan der i hver task <code>tagges</code> folk ved brugen af <code>@brugernavn</code>. Teamet har i hver task anvendt denne notations form under titlen <code>Assigned To</code>. P\u00e5 denne m\u00e5de, har teamet fors\u00f8gt, at dele sig op i mindre udviklings-teams/feature-teams. Dette skulle v\u00e6re en almindelig praksis n\u00e5r der arbejdes efter FDD.</p>"},{"location":"featureDrivenDevelopment/#inspections","title":"Inspections and quality assurance","text":"<p>Teamet har hver s\u00f8ndag m\u00f8dtes og afholde code reviews af hvorlangt de forskellige feature-teams er kommet med deres task. Her har der v\u00e6ret gennemgang af kode og feedback fra resten af teamet er blevet givet p\u00e5 feature-teamets arbejde.</p>"},{"location":"featureDrivenDevelopment/#visibility-of-progress","title":"Visibility of progress","text":"<p>Udover Kanban har teamet anvende <code>RoadMap</code> og labels til at udf\u00e6rdige et <code>feature-board</code>. Disse giver til sammen et overblik over hvilken status hver feature har og om teamet overholder tidsplanen.</p>"},{"location":"featureDrivenDevelopment/#roadmap","title":"RoadMap","text":""},{"location":"featureDrivenDevelopment/#brugen-af-labels-feature-overview","title":"Brugen af labels - Feature overview","text":""},{"location":"featureDrivenDevelopment/#plan-by-feature","title":"Plan by feature","text":"<p>Denne <code>stage</code> i FDD, omhandler projektstyring. Projektstyring er ogs\u00e5 et af de 7 fokusomr\u00e5der en systemudviklingsmetode helst skal d\u00e6kke. </p> <p>Hvis man anskuer fokusomr\u00e5det projektstyring indeholder det f\u00f8lgende:</p> <ul> <li>Projektbrief</li> <li>Foranalyse</li> <li>Valg af procesmodel</li> <li>Valg af systemudviklingsmetode</li> <li>Planl\u00e6gning af tid, ressourcer og kommunikation</li> <li>L\u00f8bende analyse af projektets situation</li> <li>Tilpasning af systemudviklingsmetode og procesmodel</li> </ul> <p>Oftest er der en tendesn til at projektstyring for mest fokus i opstarten af et projekt og derefter forsvinder fokus v\u00e6k fra projektstyring og der kan hurtigt opleves at projektets plan skrider. Derfor er det vigtigt at have fokus p\u00e5 <code>Proaktiv projektstyring</code>.</p> <p>Proaktiv projektstyring indeb\u00e6rer at opdatere de fortagede analyser, s\u00e5 de reflektere projektets aktuelle situation. Herigennem kan de udfordringer, teamet st\u00e5r overfor identificeres, hvis disse udfordringer ikke kan afviges, kan teamet tr\u00e6ffe foranstaltninger til at afb\u00f8de konsekvenserne.</p>"},{"location":"featureDrivenDevelopment/#projektbrief","title":"Projektbrief","text":"<p>I team 2s proces med FDD, er der udf\u00e6rdiget en BusinessCase. Der udover er der udf\u00e6rdiget et Project Scope Description. Disse to tilsammen udg\u00f8re <code>Projektbrief</code> for team 2.</p>"},{"location":"featureDrivenDevelopment/#foranalyse","title":"Foranalyse","text":"<p>Den udf\u00e6rdiget Foranalysen f\u00f8r valget af systemudviklingmetoden FDD er beskrevet tidligere.</p>"},{"location":"featureDrivenDevelopment/#valg-af-procesmodel","title":"Valg af procesmodel","text":"<p>Der kan argumenteres for at dette valg ikke har v\u00e6ret pr\u00e6cist nok i forbindelse med arbejdet med systemudviklingsmetoden FDD. Der er overordnet arbejde ud fra en cyklisk procesmodel. Mere om dette kan findes i Reflskioner om FDD</p>"},{"location":"featureDrivenDevelopment/#valg-af-systemudviklingsmetode","title":"Valg af systemudviklingsmetode","text":"<p>Valget af FDD var fortaget p\u00e5 baggrund af interesse fra team 2 side. Da FDD blev pr\u00e6senteret og Team 2 l\u00e6ste mere om denne, l\u00f8d den sp\u00e6nende og det med at identificere og udv\u00e6lge enkelte features, implementere disse og udvide der fra l\u00f8d passende ift. projektet. Men da valget af denne ikke har v\u00e6ret nok baseret p\u00e5 projektet situation, usikkerheder og kompleksiteter forbundet med projektet er der ogs\u00e5 valgt at skifte systemudviklings metode til Extream Programming XP. Mere om dette kan findes i Reflskioner om FDD</p>"},{"location":"featureDrivenDevelopment/#planl\u00e6gning-af-tid-fdd","title":"Planl\u00e6gning af tid, ressourcer og kommunikation","text":"<p>Teamet har som visuel metode anvendt bla. Kanban som en integrerat del af den cykliske proces, til at styre arbejdsprocessen. Kanban har best\u00e5et af f\u00f8lgende kolonner som ogs\u00e5 ses p\u00e5 billede nedenfor.</p> <ul> <li>Backlog<ul> <li>Her er all task i forbindelse med projektet lists - det har prim\u00e6rt v\u00e6ret features fra den prioriterede feature list.</li> </ul> </li> <li>To Do<ul> <li>N\u00e5r en task fra backloggen v\u00e6lges for den p\u00e5g\u00e6ldende iteration placeres denne i TO DO.</li> </ul> </li> <li>In Progress<ul> <li>N\u00e5r et udviklings-team er blevet <code>assigned to</code> den p\u00e5g\u00e6ldende task og p\u00e5begynder arbejdet med denne placeres tasken i denne kolonne.</li> </ul> </li> <li>Write Docs<ul> <li>N\u00e5r en task rent kode-m\u00e6ssiget er f\u00e6rdig, placeres tasken i denne kolonne. Dern\u00e6st udf\u00e6rdiges n\u00f8dvendig dokumentation om den p\u00e5g\u00e6ldende task. Dette kan v\u00e6re opdatering af design artefakter, sikring af sporbarhed eller dokumentation p\u00e5 denne site.</li> </ul> </li> <li>Done<ul> <li>f\u00f8rst n\u00e5r dokumentationen er skrevet placeres en task i kolonne Done, som markere at denne task er <code>f\u00e6rdig</code>.</li> </ul> </li> </ul>"},{"location":"featureDrivenDevelopment/#design-by-feature","title":"Design by feature","text":""},{"location":"featureDrivenDevelopment/#feature-create-course","title":"Feature Create Course","text":"<p>Use Case</p> <p>SSD</p> <p>OC</p>"},{"location":"featureDrivenDevelopment/#feature-showallsignsandelements","title":"Feature ShowAllSignsAndElements","text":"<p>Decompose</p> <p>SD GetAllSigns</p>"},{"location":"programmering/","title":"Programmering","text":""},{"location":"programmering/#et-distribueret-system","title":"Et distribueret system","text":"<p>Distribuerede systemer er en samling af autonome computerenheder, der samarbejder for at opn\u00e5 et f\u00f8lles m\u00e5l. Disse systemer er kendetegnet ved:</p> <ul> <li>Deres komponenter er geografisk adskilte</li> <li>Komponenterne kommunikere over netv\u00e6rk<ul> <li>Protokoller som HTTP/HTTPS, TCP/IP</li> </ul> </li> <li>Ressoucer deles og opgaver kan fordeles mellem flere computere, hvilket forvedre b\u00e5de ydeevne og p\u00e5lidelighed<ul> <li>Fejlrolerance: Systemet kan forts\u00e6tte med at fungere korrekt, selvom en eller flere komponenter fejler.</li> </ul> </li> </ul>"},{"location":"programmering/#overordnet-arkitektur","title":"Overordnet arkitektur","text":"<p>Arkitekturen i projekt <code>RallyObedience</code> kan beskrives i termer af lagdelt arkitektur, som typisk opdeles i pr\u00e6sentationslag, forretninglogiklag og datalag.</p> <p>Pr\u00e6sentationslag: Frontend Blazor Dette lag er ansvarlig for at inteagere med brugeren. Det viser brugergr\u00e6nsefladen og sender brugerens input videre til backend-tjenesterne.</p> <ul> <li>Komponent: <code>rally-blazor</code></li> <li>Funktion: Viser data til brugeren og sender brugerens input som HTTP-request til API'en</li> </ul> <p>Forretningslogiklag: API og Dataadgang Backend Dette lag h\u00e5ndtere applikationens kernefunktionalitet. Det modtager <code>requests</code> fra pr\u00e6sentationslaget, nehnadler forretningslogik gennem implementerede <code>controllers</code> og <code>services</code> og kommunikere med datalaget.</p> <ul> <li>Komponent: <code>rally-webapi</code></li> <li>Funktion: Behandler forretningslogi og regler, validere input, udf\u00f8rer beregninger og sender <code>requests</code> til datalaget.</li> </ul> <p>Datalag: Database MSSQL Dette lag er ansvarlig for at gemme og hente data. Det modtager <code>requests</code> fra forretningslogiklaget og sender <code>respons</code> med de n\u00f8dvendige data retur.</p> <ul> <li>Komponent: sqlpreview</li> <li>Funktion: H\u00e5ndtere lagring, hentning og administration af data.</li> </ul>"},{"location":"programmering/#samspil-mellem-lagene","title":"Samspil mellem lagene","text":"<ol> <li>Pr\u00e6sentaionslager: Brugeren interagere med Blazor-applikationen, som sender en HTTP-anmodning til API'en for at udf\u00f8rer en given funktionalitet (f.eks. valider bane med id x ud fra niveau begynder).</li> <li>Forretningslogiklag: API'en modtager anmodningen <code>controlleren</code>, behandler forretningslogikken <code>services</code>. Og sender en SQL-foresp\u00f8rgsel til databasen gennem <code>repo</code>.</li> <li>Datalag: MSSQL-databasen udf\u00f8rer foresp\u00f8rgslen og returnere resultatet til API'en (information om bane med id-x).</li> <li>Forretninglogiklaget: API'en behnadler de modtagne data og sender et svar tilbage til Blazor-applikationen.</li> <li>Pr\u00e6sentationslag: Blazor-applikationen modtager svaret og viser dataene til brugeren (udf\u00f8rer et validerings tjek p\u00e5 banens information, om dens collection af skilter overholder reglementet for niveau begynder og returnere en besked med information om hvad den mangler for at opfylde eller OK - den er valideret).</li> </ol> <p>Ved at opdele systemet i disse lag fors\u00f8ge der at opn\u00e5 klar <code>separation of concerns</code>, hvilket g\u00f8r det lettere at udvikle, vedligholde og skalere systemet.</p>"},{"location":"programmering/#vores-brug-af-docker","title":"Hvordan Containerization Illustere Vores Distribuerede System","text":"<p>I projekt <code>RallyObedience</code> har vi anvendt <code>Docker</code> til at containerisere tre hovedkomponenter:</p> <ol> <li>Frontend - Blazor</li> <li>API og Dataadgang</li> <li>Database</li> </ol> <p>Hver af disse komponenter k\u00f8rer i sin egen container, hvilket giver flere fordele:</p> <ul> <li>Frontend Blazor Container:<ul> <li>Indeholder vores Blazor applikation, som pr\u00e6sentere brugergr\u00e6nsefladen</li> </ul> </li> <li>API og Data Container:<ul> <li>Indeholder vores backend API, som h\u00e5ndtere forretningslogi og dataadgang</li> </ul> </li> <li>Database Container:<ul> <li>Indeholder vores MSSQL database, som gemmer alle data for systemet</li> </ul> </li> </ul> <p>Ved at k\u00f8rer hver komponent i sin egen container sikrer vi isolering og uafh\u00e6ngighed mellem dem. Dette g\u00f8r det lettere at udvikle, teste og deployere hver komponent separat. Desuden kan vi hurtigt oprette nye milj\u00f8er eller skalere individuelle komponenter efter behov. l\u00e6s mere om containerization p\u00e5 teknologisiden.</p>"},{"location":"programmering/#docker-files-og-docker-compose","title":"Docker files og Docker Compose","text":"<p>Ved at bruge Docker files og Docker Compose kan vi definere og k\u00f8re vores distribuerede systm som et s\u00e6t af sammenh\u00e6ngende tjenester <code>(Multicontainer applikation)</code>, hvilket g\u00f8r det nemt at ops\u00e6tte og administrer milj\u00f8et.</p> <p>Blazor Docker File <pre><code>FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base\nWORKDIR /app\nEXPOSE 8080\nEXPOSE 8081\n\nFROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\nARG BUILD_CONFIGURATION=Release\nWORKDIR /src\nCOPY [\"RallyObedience.Blazor/RallyObedience.Blazor.csproj\", \"RallyObedience.Blazor/\"]\nRUN dotnet restore \"./RallyObedience.Blazor/RallyObedience.Blazor.csproj\"\nCOPY . .\nWORKDIR \"/src/RallyObedience.Blazor\"\nRUN dotnet build \"./RallyObedience.Blazor.csproj\" -c $BUILD_CONFIGURATION -o /app/build\n\nFROM build AS publish\nARG BUILD_CONFIGURATION=Release\nRUN dotnet publish \"./RallyObedience.Blazor.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false\n\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\nENTRYPOINT [\"dotnet\", \"RallyObedience.Blazor.dll\"]\n</code></pre></p> <p>API og Data Docker File <pre><code>FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\nWORKDIR /src\nCOPY [\"RallyObedienceCourse.API/RallyObedienceCourse.API.csproj\", \"RallyObedienceCourse.API/\"]\nCOPY [\"RallyObedience.Data/RallyObedience.Data.csproj\", \"RallyObedience.Data/\"]\nRUN dotnet restore \"RallyObedienceCourse.API/RallyObedienceCourse.API.csproj\"\nCOPY . .\nWORKDIR \"/src/RallyObedienceCourse.API\"\nRUN dotnet build \"RallyObedienceCourse.API.csproj\" -c Release -o /app/build\nRUN dotnet publish \"RallyObedienceCourse.API.csproj\" -c Release -o /app/publish /p:UseAppHost=false\n\nFROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final\nWORKDIR /app\nCOPY --from=build /app/publish .\nENTRYPOINT [\"dotnet\", \"RallyObedienceCourse.API.dll\"]\n</code></pre></p> <p>Docker Compose File: bem\u00e6rk at der i denne visning er maskeret vigtige inputs ved brug af <code>${}</code> notationsformen Hvis du rent faktisk skal stukturer din Docker compose fil p\u00e5 denne m\u00e5de og ikke inds\u00e6tte v\u00e6riderne direkte skal der oprettes en <code>.env</code> - fil som tillader brugen af milj\u00f8variabler. Denne skal placeres i samme mappe som din <code>docker-compose</code>-fil og definere variablerne der.</p> <pre><code>version: '3.8'\n\nservices:\n  sqlpreview:\n    image: mcr.microsoft.com/mssql/server:2022-preview-ubuntu-22.04\n    environment:\n      - ACCEPT_EULA=Y\n      - MSSQL_SA_PASSWORD=${MSSQL_SA_PASSWORD}\n      - MSSQL_PID=Evaluation\n    ports:\n      - \"1433:1433\"\n\n  rally-webapi:\n    image: rally-webapi:latest\n    environment:\n      - ConnectionStrings__connectionDev=Server=sqlpreview,1433;Database=${DATABASE_NAME};User Id=${DB_USER};Password=${DB_PASSWORD};Trusted_Connection=True;MultipleActiveResultSets=True;\n    ports:\n      - \"8080:80\"\n    depends_on:\n      - sqlpreview\n\n  rally-blazor:\n    image: rally-blazor:latest\n    environment:\n      - ASPNETCORE_URLS=http://+:80\n    ports:\n      - \"5000:80\"\n    depends_on:\n      - rally-webapi\n</code></pre> <p>Forklaring af docker compose</p> <ul> <li>sqlpreview:<ul> <li>Denne container k\u00f8rer en MSSQL databse. Milj\u00f8variabler bruges til at konfigurer databasen, og port 1433 eksporneres for adgang.</li> </ul> </li> <li>rally-webapi:<ul> <li>denne container k\u00f8rer API'en. Den er afh\u00e6nig af <code>sqlreview</code> containeren for databaseadgang. Milj\u00f8variabler bruges til at konfigurere databaseforbindelsen, og port 8080 eksporneres for adgang.</li> </ul> </li> <li>rally-blazor:<ul> <li>Denne container k\u00f8rer Blazor frontend applikationen. Den er afh\u00e6ning af <code>rally-webapi</code> container for at kunne kommunikere med backend API'en. Port 5000 eksporneres for adgang.</li> </ul> </li> </ul>"},{"location":"programmering/#blazor","title":"Blazor","text":"<p>Under projektet blazor ligger alt frontend koden.</p>"},{"location":"programmering/#data","title":"Data","text":"<p>I projektet data er data-laget. Der ligger alt forbindelse til databasen.  I mappen entities, indholder den alle de klasser, der bliver brugt til at lave migrations til databasen. Herigennem er der ogs\u00e5 C# attributes, for eks. at fort\u00e6lle databasen om der er tale om en Primary key eller ForeignKey  <pre><code>[Key]\npublic int Id { get; set; }\n...\n[ForeignKey(\"Creator\")]\npublic string CreatorId { get; set; }\n</code></pre> Disse relationer f\u00e5r betydning, n\u00e5r tabeller bliver oprettet i databasen.</p> <p>I mappen DbContexts finder vi context til databasen. Vi ser f\u00f8rst at ROContext arver fra IdentityDbContext: <code>public class ROContext : IdentityDbContext&lt;User&gt;</code>  Det betyder at der er brugt ASP.NET Cores metode for at oprette og autorisere brugere.  Herefter ser vi nogle properties, hvor de forskellige tables bliver sat i databasen. De tabeller der bliver oprettet igennem Identity, er dog ikke vist her.</p> <pre><code>public DbSet&lt;Item&gt; Items { get; set; }\npublic DbSet&lt;Course&gt; Courses { get; set; }\npublic DbSet&lt;UserCourse&gt; UserCourses { get; set; }\npublic DbSet&lt;CourseItem&gt; courseItems { get; set; }\n</code></pre> <p>Under metoden <code>protected override void OnModelCreating(ModelBuilder modelBuilder)</code>, bliver der oprettet alle de relationer, der i databasen imellem de forskellige tabeller.  <pre><code>modelBuilder.Entity&lt;UserCourse&gt;()\n    .HasOne(uc =&gt; uc.User)\n    .WithMany(u =&gt; u.UserCourses)\n    .HasForeignKey(utc =&gt; utc.UserId)\n    .OnDelete(DeleteBehavior.Restrict);\n</code></pre> Her  oprettes der tabellen <code>UserCourse</code>. Tabellen har et one-to-many relationship. Den tabel har en relation til \u00e9n User med Mange UserCourses. De er relateret hinanden igennem UserId.</p> <p>Slutligt bliver der seedet data til databasen. <pre><code>modelBuilder.Entity&lt;Item&gt;()\n.HasData(\nnew Item()\n{\n    Id = 1,\n    Name = \"Start\",\n    Description = \"...\",\n},\n....\n</code></pre></p>"},{"location":"programmering/#repositories","title":"Repositories","text":"<p>Under repositories, har vi de steder hvor vi sender vores metoder til databasen. Det kunne f.eks v\u00e6re n\u00e5r vi skal have alle baner fra en bestemt user:</p> <pre><code>public async Task&lt;List&lt;Course&gt;&gt; GetAllCoursesByUserIdAsync(string userId)\n{\n    // Get all TrainingCourses by UserId from the database\n    var courses = await _context.UserCourses\n        .Where(utc =&gt; utc.UserId == userId)\n        .Select(utc =&gt; utc.Course)\n        .ToListAsync();\n\n    return courses;\n}\n</code></pre> <p>P\u00e5 den m\u00e5de har vi seperation of concern, hvor vi delt vores kode op i mindre dele og vores metoder ikke overlapper hinanden. Det g\u00f8r det nemmere at vedligeholde, fejlfinde og teste.</p>"},{"location":"programmering/#api-opret-bane-backend","title":"API: Opret bane (Backend)","text":"<p>I API projektet er der hvor st\u00f8rstedelen logikken er samlet, og hvor der bliver lavet diverse kald til databasen.  API projektet har f\u00f8lgende hovedmapper:  Controllers: I API laget er arkitekturen opsat ved at vi har en controller, dens rolle er at forbinde brugerens input med APIens business logic.  Services:  For at indkapsle logikken er der oprettet services.  Models / DTOs:  De forskellige klasser, brugerne har tilgang til, er oprettet sig DTOs.  DTOs har ogs\u00e5 den fordel at de kan mappes til data klasser. Derved er der kontrol over, hvilke data vores brugere skal kunne se og \u00e6ndre.  MappingProfiles:  Her kan vi mappe DTOs til dataklasser.</p>"},{"location":"programmering/#flowet-for-opret-bane","title":"Flowet for Opret Bane","text":"<p>Herunder vil der gennemg\u00e5 hvordan der bliver oprettet en bane, igennem backend, fra n\u00e5r bruger trykker opret, til der bliver gemt i databasen.  Det skal n\u00e6vnes at frontend st\u00e5r for en r\u00e6kke andre dele. Det kan l\u00e6ses i nedst\u00e5ede \"Oprettelse af kursus\"</p> <p> N\u00e5r bruger klikker \"Opret Bane\", vil metoden <code>CreateEmptyCourse?</code> blive kaldt.</p> <pre><code>private async Task CreateEmptyCourse()\n{\n    ...\n\n    apiEndPoint = Configuration.GetSection(\"APIEndpoint\")[\"Url\"];\n    string apiUrl = $\"{apiEndPoint}/api/course/create-course/{userId}\";\n    ...\n}\n</code></pre> <p>Den metode vil kalde endpointet i API laget, i vores CourseController  <code>/api/course/create-course/{userId}</code> <pre><code>[HttpPost(\"create-course/{userId}\")]\npublic async Task&lt;IActionResult&gt; CreateCourse(string userId)\n{\n    var courseToReturn = await _courseService.CreateCourse(userId);\n\n    if (courseToReturn == null) \n    {\n        return BadRequest(\"Failed to create course or unauthorized access.\");\n    }\n\n    return Ok(courseToReturn);\n}\n</code></pre> I overst\u00e5ende ses det at der er indsat en attribute <code>[HttpPost(\"create-course/{userId}\")]</code> Her bliver der fortalt at der bliver brugt af en HTTP POST method, og URi til det endpoint vi bruger. Derudover s\u00e5 bliver den nuv\u00e6rendes bruger id, indsat som en parameter. Dette ID skal vi bruge til at oprette en bane.  Derudover er metod async, og vi venter p\u00e5 metoden <code>CreateCourse</code> fra <code>courseService</code> p\u00e5 at blive f\u00e6rdig f\u00f8r vi forts\u00e6tter.  Async er brugt, da der skal ventes p\u00e5 databasen om at blive f\u00e6rdig.  Fra Controller kommer vi over til service laget, til <code>CreateCourse</code>: <pre><code>public async Task&lt;CourseDto&gt; CreateCourse(string userID)\n{\n\n    var course = _courseRepo.CreateCourse(userID);\n    if (course == null || course.Value.CreatorId == null)\n    {\n        return null;\n    }\n\n    if (userID != course.Value.CreatorId)\n    {\n        return null;\n    }\n\n    var userIds = new List&lt;string&gt; { userID };\n\n    await _courseRepo.ShareCourseAsync(course.Value.Id, userIds);\n\n    var courseDto = _mapper.Map&lt;CourseDto&gt;(course.Value);\n\n    return courseDto;\n}\n</code></pre> F\u00f8rst forlader vi faktisk API laget og g\u00e5r over til Data laget til 'Repositories'. Som beskrevet tidligere, h\u00e5ndterer 'Repositories' kaldene til databasen.  <pre><code>public ActionResult&lt;Course&gt; CreateCourse(string userId)\n{    \n    string name = $\"Untitled Course\";\n    Course course = new Course \n    {\n        Name = name,\n        CreatorId = userId                \n    };\n\n    // Save the new TrainingCourse to the database\n    _context.Courses.Add(course);\n    _context.SaveChanges();\n    return course;\n}\n</code></pre> Igennem her bliver der her sat at default navn: <code>string name = $\"Untitled Course\";</code>  Og derefter bliver der instatieret et nye <code>Course</code> objekt, med det default navn og id'et p\u00e5 den bruger vi fik fra parameteret tilbage fra <code>CourseController</code>  Denne bane bliver s\u00e5 oprettet i databasen i tabellen Course '_context.Courses.Add(course);'  Slutligt bliver denne bane retureret tilbage til <code>CourseService</code> og vi kan kigge n\u00e6rmere p\u00e5 n\u00e6ste skridt:  <pre><code>if (course == null || course.Value.CreatorId == null)\n{\n    return null;\n}\n</code></pre> Her bliver der tjekket om der er sat en bane/course og om denne bane ogs\u00e5 har et <code>CreatorId</code> (Det er brugerns ID).  Herfra bliver der oprettet en liste med <code>userIds</code>, listen her skal bruges til at dele banen.  F\u00f8rste gang banen bliver oprettet er den delt med den bruger der har oprettet banen (Creator)  Vi g\u00e5r igen ind til <code>CourseRepo</code> til metoden <code>ShareCourseAsync</code> <pre><code>var userIds = new List&lt;string&gt; { userID };\nawait _courseRepo.ShareCourseAsync(course.Value.Id, userIds);\n</code></pre> F\u00f8rst bliver der tjekket om banen existerer, og om alle brugere eksisterer og dern\u00e6st inds\u00e6tter dem i tabellen <code>UserCourses</code> <pre><code>public async Task&lt;ActionResult&gt; ShareCourseAsync(int courseId, List&lt;string&gt; userIds)\n{\n    try\n    {\n        // Find the course by ID\n        var course = await _context.Courses.FindAsync(courseId);\n\n        if (course == null)\n        {\n            return new NotFoundResult();\n        }\n\n        foreach (var userId in userIds)\n        {\n            // Check if the user exists\n            var user = await _context.Users.FindAsync(userId);\n\n            if (user == null)\n            {\n                // Handle invalid user ID\n                continue;\n            }\n\n            // Add a new entry to the UserTrainingCourse table\n            _context.UserCourses.Add(new UserCourse { UserId = userId, CourseId = courseId, CreatorId = course.CreatorId });\n        }\n\n        // Save changes to the database\n        SaveChangesAsync();\n\n        return new OkResult();\n    }\n    catch (Exception ex)\n    {\n        // Handle any exceptions and return an appropriate error response\n        return new StatusCodeResult(500);\n    }\n}\n</code></pre> Vi afventer at <code>await _courseRepo.ShareCourseAsync(course.Value.Id, userIds);</code> er f\u00e6rdig g\u00e5r vi videre til n\u00e6ste skridt i `CourseService``</p> <pre><code>var courseDto = _mapper.Map&lt;CourseDto&gt;(course.Value);\nreturn courseDto;\n</code></pre> <p>Her mapper vi den oprettet <code>Course</code> til en <code>CourseDto</code> - Det er d\u00e9n datatype vi returnerer til <code>CourseController</code>  Den vil til sidst tjekke om <code>Course</code> er oprettet og give vores bruger besked p\u00e5 dette <pre><code>if (courseToReturn == null) \n{\n    return BadRequest(\"Failed to create course or unauthorized access.\");\n}\n\nreturn Ok(courseToReturn);\n</code></pre> Er banen oprettet vil der giver en status code 200, men de v\u00e6rdier, vi mappede fra <code>Course</code> til <code>CourseDto</code>, som samtidig vil blive serialized til JSON.  Dette JSON objekt kan s\u00e5 bruges videre til at arbejde med frontend.</p>"},{"location":"programmering/#test","title":"Test","text":"<p>Igennem projektets systemudviklingsmetoder er der blevet skrevet tests.  Her vil vi gennemg\u00e5 test for <code>CreateCourse</code> <pre><code>public CourseControllerTests()\n{\n    _mockService = new Mock&lt;ICourseService&gt;();\n    _mockMapper = new Mock&lt;IMapper&gt;();\n    _controller = new CourseController(_mockService.Object, _mockMapper.Object);\n}\n\n[TestMethod]\npublic void CreateCourse_ShouldReturnCreatedCourse()\n{\n    // Arrange: Setup mock repository and test course\n    var course = new CourseDto { Id = 1, Name = \"Untitled Course\", CourseItems = new List&lt;CourseItemDto&gt;() };\n    var course1 = new CourseDto { Id = 1, Name = \"Untitled Course\", CourseItems = new List&lt;CourseItemDto&gt;() };\n\n    _mockService.Setup(Service =&gt; Service.CreateCourse(\"1\")).ReturnsAsync(course);\n\n    // Act: Call CreateCourse method\n    var result = _controller.CreateCourse(\"1\");\n\n    // Assert: Check if the returned course is as expected\n    var okResult = result.Result as OkObjectResult;\n    var returnValue = okResult.Value as CourseDto;\n    Assert.AreEqual(course1.Id, returnValue.Id);\n    Assert.AreEqual(course1.Name, returnValue.Name);\n    Assert.AreEqual(course1.CourseItems.ToString(), returnValue.CourseItems.ToString());\n}\n</code></pre> Teamet har brugt samme struktur for alle test: Arrange, Act og Assert (AAA).  Arrange: Vi arranger dataen f\u00f8rst ved at instatiere de objekter (<code>CourseDto</code>), der bliver returnet igenem den metode vi tester: <pre><code>var course = new CourseDto { Id = 1, Name = \"Untitled Course\", CourseItems = new List&lt;CourseItemDto&gt;() };\nvar course1 = new CourseDto { Id = 1, Name = \"Untitled Course\", CourseItems = new List&lt;CourseItemDto&gt;() };\n</code></pre></p> <p>Under arrange bliver der ogs\u00e5 Mocking, s\u00e5 vores kode har de metoder der skal bruges. <code>_mockService.Setup(Service =&gt; Service.CreateCourse(\"1\")).ReturnsAsync(course);</code></p> <p>Her er der sagt at <code>CreateCourse</code> er en del af interfacet <code>iCourseService</code>, som set i constructor. Derudover at vi vil k\u00f8re metoden <code>CreateCourse</code> med id = 1, som parameter.  Act:  Der bliver arrageret som den metoden, der skal testes: <code>CreateCourse</code> fra <code>CourseController</code> og vi gemmer det i en variabel:  <code>var result = _controller.CreateCourse(\"1\");</code> Assert: Til sidst kan vi se om der bliver returneret det vi forventer: <pre><code>var okResult = result.Result as OkObjectResult;\nvar returnValue = okResult.Value as CourseDto;\nAssert.AreEqual(course1.Id, returnValue.Id);\nAssert.AreEqual(course1.Name, returnValue.Name);\nAssert.AreEqual(course1.CourseItems.ToString(), returnValue.CourseItems.ToString());\n</code></pre> Vi forventer f\u00f8rst at der bliver returneret et HTTP response 200 og vi f\u00e5r <code>CourseDto</code> data.  I den CourseDto data, skal id'et v\u00e6re det samme som <code>course1.id</code>  Det samme g\u00e6lder navnet og den tomme <code>CourseItems</code> liste.</p>"},{"location":"programmering/#oprettelse-af-bane","title":"Oprettelse af bane","text":"<p>For at oprette et kursus i vores system, skal brugeren f\u00f8rst registrere sig og logge ind. Dette er n\u00f8dvendigt for at sikre, at kun autoriserede brugere kan oprette kurser.</p>"},{"location":"programmering/#registrering","title":"Registrering","text":"<p>For at registrere, skal brugeren udfylde en formular med f\u00f8lgende felter:</p> <ul> <li>Fornavn</li> <li>Efternavn</li> <li>Brugernavn</li> <li>Adgangskode</li> </ul> <p>N\u00e5r formularen er udfyldt, sendes dataen til vores backend via en HTTP POST-anmodning til <code>/api/Auth/Register</code> endpointet.</p>"},{"location":"programmering/#login","title":"Login","text":"<p>Efter registrering kan brugeren logge ind ved at indtaste deres brugernavn og adgangskode i login-formularen. Disse oplysninger sendes til vores backend via en HTTP POST-anmodning til <code>/api/Auth/Login</code> endpointet. Hvis login er succesfuldt, returnerer backenden en token, som gemmes i lokal lagring for senere brug.</p>"},{"location":"programmering/#oprettelse-af-kursus","title":"Oprettelse af kursus","text":"<p>N\u00e5r brugeren er logget ind, kan de oprette et nyt kursus ved at klikke p\u00e5 \"Opret bane\" knappen. Dette udl\u00f8ser en HTTP POST-anmodning til <code>/api/course/create-course/{userId}</code> endpointet, hvor <code>{userId}</code> er brugerens unikke ID. Hvis oprettelsen er succesfuld, returnerer backenden detaljerne for det nyoprettede kursus.</p>"},{"location":"programmering/#ekstraktion-af-userid-fra-token","title":"Ekstraktion af userId fra Token","text":"<p>N\u00e5r en bruger logger ind, genererer vores backend en token, som indeholder brugerens unikke ID (<code>userId</code>). Dette <code>userId</code> er indlejret i token som en af dens claims.</p> <p>N\u00e5r vi skal oprette et nyt kursus, har vi brug for at kende <code>userId</code> for den aktuelt logget ind bruger. Dette <code>userId</code> er gemt i token, som vi har gemt i lokal lagring efter brugeren loggede ind.</p> <p>For at f\u00e5 <code>userId</code> fra token, g\u00f8r vi f\u00f8lgende:</p> <ol> <li>Vi henter token fra lokal lagring.</li> <li>Vi parser token ved hj\u00e6lp af en <code>JwtSecurityTokenHandler</code>. Dette giver os et <code>JwtSecurityToken</code> objekt.</li> <li>Vi finder \"nameidentifier\" claim i <code>JwtSecurityToken</code> objektet. V\u00e6rdien af denne claim er <code>userId</code>, som vi har brug for.</li> </ol> <p>Her er en kodebid, der viser, hvordan det g\u00f8res:</p> <p>Nu har vi <code>userId</code> for den aktuelt logget ind bruger, som vi kan bruge til at oprette et nyt kursus.</p>"},{"location":"systemudvikling/","title":"Systemudvikling","text":"<p>Team 2 p\u00e5 3. semester skal v\u00e6lge og arbejde med mindst 2 systemudviklingsmetoder til deres eksamensprojekt. De vil reflektere over fordele og ulemper ved hver metode og tilpasse dem til projektet efter behov. Denne side vil give et overblik over de valgte metoder, samt dokumentere deres anvendelse i projektet <code>Rally Obedience</code>.</p>"},{"location":"systemudvikling/#opstarts-fasen","title":"Opstarts fasen","text":"<p>Inden den f\u00f8rste systemudviklingsmetode v\u00e6lges er der udf\u00e6rdiget en foranalyse, som indeholder:</p> <ul> <li>Businesscase</li> <li>Krav til systemet</li> <li>Sprogbrug i dom\u00e6net</li> </ul> <p>Denne foranalyse er udf\u00e6rdigt med baggrund i en pr\u00e6sentation af projektet som PO afholdte i starten af 3.semester og dermed i opstartsfasen af projektet. Det betyder ogs\u00e5 at den f\u00f8rste iteration af foranalysen tager udgangspunkt i 2.semester stof, da Team 2 p\u00e5 dette tidspunkt i projektet ikke var introduceret til nye begreber eller ikke har tilegnet sig mere viden siden 2.semester om begreberne:</p> <ul> <li>Procesmodeller</li> <li>Fokusomr\u00e5der</li> <li>Systemudviklingsmetoder</li> <li>Teknikker</li> <li>V\u00e6rkt\u00f8jer</li> <li>Usikkerhedder</li> <li>Kompleksitet</li> </ul>"},{"location":"systemudvikling/#Foranalyse1.iteration","title":"Foranalyse - 1.iteration","text":""},{"location":"systemudvikling/#krav-til-systemet","title":"Krav til systemet","text":"<p>Overordnet kan systemet deles op i to sub-systemet. Et Bane system og et Chat system. F\u00f8lgende lister de identificerede krav til hvert af de to systemer.</p>"},{"location":"systemudvikling/#bane-system","title":"Bane system","text":"<ul> <li>Automatisk skiltenummer, pile og udfyldelse af skilteoversigt</li> <li>M\u00e6rker p\u00e5 baner, niveau, tema og antal skilte</li> <li>Lave baner, der overholder reglementet</li> <li>Lave baner, til tr\u00e6ning, som ikke n\u00f8dvendigvis overholder relementet</li> <li>Samarbejde om bane design i reltid</li> <li>Oprette interaktivt baner, tr\u00e6kke og slippe skilte ind p\u00e5 banen</li> <li>Dele baner med andre instukrt\u00f8rer/dommer plus tildele dem rettigheder som ReadOnly eller Edit</li> </ul>"},{"location":"systemudvikling/#chat-system","title":"Chat system","text":"<ul> <li>oprette en tr\u00e5 mellem to instrukt\u00f8rer</li> <li>oprette en gruppechat mellem flere instrukt\u00f8rer</li> <li>evt. udvide de to ovenst\u00e5ende til at inkludere dommere</li> </ul>"},{"location":"systemudvikling/#Businesscase","title":"Businesscase","text":""},{"location":"systemudvikling/#beskrivelse-af-problemomradet","title":"Beskrivelse af problemomr\u00e5det","text":"<p>Forretningsm\u00e6ssig baggrund - Nordfyns Civile Hundef\u00f8rerforening (NcH) er en del af organisationen Danmarks Civile hundef\u00f8rerforening (DCH).  DcH tilbyder undervisning i forskellige typer af hundesport, heriblandt Rally lydighed.  NcH har en r\u00e6kke frivillige instrukt\u00f8rer som st\u00e5r for denne undervisning af ekvipage (hund og f\u00f8rer). En del af instrukt\u00f8rens rolle er at designe baner som ekvipage skal gennemf\u00f8res i tr\u00e6ning.  P\u00e5 nuv\u00e6rende tidspunkt anvender instrukt\u00f8rerne et PowerPoint (PPT) til at designe disse baner og Facebook som kommunikationsplatform.  Ved afholdelse af konkurrencer st\u00e5r en landsd\u00e6kkende dommer for at designe banen. Det antages at dommerne anvender samme PPT som instrukt\u00f8rerne i denne proces.</p> <p>Forretningsm\u00e6ssig problemstilling - P\u00e5 nuv\u00e6rende tidspunkt, er der ikke \u00e9t dedikeret v\u00e6rkt\u00f8j som rummer alle NcH og Dommeres behov. Den nuv\u00e6rende praksis for planl\u00e6gning, design og deling af tr\u00e6ningsbaner st\u00e5r dog overfor flere v\u00e6sentlige udfordringer.  Disse inkluderer ineffektivitet i oprettelse og deling af baner, manglende evne til let at tilpasse baner til specifikke niveauer eller temaer, og vanskeligheder ved at sikre overensstemmelse med officielle regler.  Den eksisterende l\u00f8sning baseret p\u00e5 PowerPoint og Facebook tilbyder begr\u00e6nset funktionalitet og underst\u00f8tter ikke effektivt samarbejde mellem instrukt\u00f8rer eller kommunikation med engagerede hundef\u00f8rere.</p>"},{"location":"systemudvikling/#kravspecifikation","title":"Kravspecifikation","text":"<p>Idet at NcH skal bruge et v\u00e6rkt\u00f8j, der skal kunne fungere som en platform, hvor flere intressenter skal kunne samarbejde omkring en bane, b\u00e5de samtidig, men ogs\u00e5 forskudt, er det blevet fastlagt, at en webbaseret l\u00f8sningen ville passe bedst til NcHs krav. I og med at de allerede bruger Facebook og Powerpoint, skal de heller ikke invistere i nyt udstyr, men de kan bruge de enheder, som de allerede har til r\u00e5dighed.</p>"},{"location":"systemudvikling/#interessenter","title":"Interessenter","text":""},{"location":"systemudvikling/#kerneinteressenter","title":"Kerneinteressenter:","text":"<ol> <li>Nordfyns Civile Hundef\u00f8rerforening (NcH)</li> <li>Instrukt\u00f8rer</li> </ol>"},{"location":"systemudvikling/#nre-primrer-interessenter","title":"N\u00e6re Prim\u00e6rer interessenter:","text":"<ol> <li>Danmarks Civile Hundef\u00f8rerforening (DcH)</li> <li>Dommere</li> <li>Hundef\u00f8rer</li> </ol>"},{"location":"systemudvikling/#scenarie-oversigt","title":"Scenarie oversigt","text":""},{"location":"systemudvikling/#0-scenariet","title":"0-scenariet","text":"<p>NcH forts\u00e6tter med at bruge PowerPoint og Facebook til oprettelse af baner og kommunikarion</p> <ul> <li>Fordele: Der skal ikke investeres i et nyt system. Ingen tidskr\u00e6vende overgangsfase eller introduktion til det nye system.</li> <li>Ulemper: Den nuv\u00e6rende ineffektive og tidskr\u00e6vende proces ved banedesign forts\u00e6ttes u\u00e6ndret.</li> </ul>"},{"location":"systemudvikling/#1-scenariet","title":"1-scenariet","text":"<p>Form\u00e5let - At tilbyde en platform for NcH, der giver deres instrukt\u00f8rer mulighed for at samarbejde om design af baner, mulighed for at dele, gemme og genbruge oprettede baner.  Derudover skal instrukt\u00f8rerne have mulighed for at kommunikere med hinanden gennem platformen. B\u00e5de i form af chat funktionalitet, s\u00e5 de instrukt\u00f8rerende kan vidensdele og andet, og s\u00e5 de kan kommunikere omkring bane design.</p> <p>Forretningsm\u00e6ssig l\u00f8sningsbeskrivelse - L\u00f8sningen skal dels sikre, at design og deling af rally lydighed baner foreg\u00e5r mere effektivt og struktureret, og dels muligg\u00f8re realtidssamarbejde og feedback mellem instrukt\u00f8rer.</p> <p>Den nuv\u00e6rende praksis med manuelt at tegne baner i PowerPoint og dele dem i en Facebook-gruppe, hvor feedback gives i kommentarfeltet, erstattes af en integreret webbaseret platform. Denne platform vil g\u00f8re det muligt for instrukt\u00f8rer at designe baner, validere dem automatisk mod reglementet, dele dem med specifikke personer eller grupper, og modtage og give feedback direkte i systemet.</p> <p>I f\u00f8rste omgang er l\u00f8sningen tilt\u00e6nkt rally lydighed instrukt\u00f8rer, men med potentiale for senere at udvide til dommer.  Det vurderes, at l\u00f8sningen umiddelbart kan forbedre kvaliteten og effektiviteten af tr\u00e6ning betydeligt og fremme et t\u00e6ttere samarbejde og vidensdeling mellem instrukt\u00f8rer og evt. dommere.</p> <p>it-m\u00e6ssig l\u00f8sningsbeskrivelse - Rally Lydighed udvikles som en webapplikation ved brug af Blazor for front-end, for at visualisere data og funktionaliteter p\u00e5 en dynamisk og interaktiv m\u00e5de. </p> <p>Back-end delen bygges i ASP.NET med C# i en objektorienteret, lagdelt arkitektur, som kommunikerer med databasen og sender respons til front-end. </p> <p>Databasen h\u00e5ndteres via SQL Server Management Studio (SSMS) for robust og effektiv dataopbevaring. </p> <p>Disse komponenter arbejder sammen for at danne et distribueret system, som tilsammen sikrer en modul\u00e6r og fremtidssikret l\u00f8sning, hvor det er muligt at udvide med yderligere funktionalitet og let at vedligeholde systemet.</p> <p>Forretningsm\u00e6ssige effekter - \u00d8konomiske effekter - Bedre vilk\u00e5r og mere effektivt at v\u00e6re intrukt\u00f8r, hvilket kan g\u00f8re det mere attraktivt at v\u00e6re instrukt\u00f8r. hvis Nch opn\u00e5r flere instrukt\u00f8rer kan der oprettes flere tr\u00e6ningshold og med flere tr\u00e6ningshold vil der opst\u00e5 en \u00f8get indt\u00e6gt.</p> <p>Gevinster - En webapplikation vil give NcH en mere effektiv metode at designe baner. Gennem bedre kommunikation og samarbejde, vil disse baner blive forbedret i forhold til f\u00e6llesskabets feedback. Det vil give instrukt\u00f8rerne en st\u00f8rre gl\u00e6de og lyst til at oprette baner og dele dem med hinanden. Samtidig er der et katalog over alle banerne, der alt sammen vil v\u00e6re med til at \u00f8ge f\u00e6llesskabet og kvaliteten af baner og tr\u00e6ning.</p> <p>Implementering og opf\u00f8lgning - Platformen skal implementeres gennem opl\u00e6ring og opf\u00f8lgning ved at g\u00e5 igennem f\u00f8lgende:</p> <ul> <li>Platformen og dokumentation overdrages til Product Owner (PO) - PO f\u00e5r en detaljeret gennemgang af ops\u00e6tning og brug af platformen. Der skal aftales faste tidspunkter til gennemgang og feedback.</li> <li>Test og validering - NcH medlemmer f\u00e5r i f\u00f8rste omgang, som de eneste adgang til systemet. Dette skal ses som en demo. I en given periode f\u00e5r de lov at anvende og teste platformen. De afgiver feedback til PO.</li> <li>Feedback og tilpasning - Den feedback NcH har videregivet PO gennemg\u00e5s mellem udviklingsteamet og PO. Platformen tilpasses i forhold til feedbacken, s\u00e5 \u00f8nsker bliver implementeret og fejl tilrettes.</li> </ul> <p>Dette skal ses som en cyklisk proces, der forts\u00e6tter indtil NcH oplever det produkt som de eftersp\u00f8rger. Herefter kan platformen udgives som en f\u00e6rdig version, hvor DcHs dommer f\u00e5r adgang.</p> <p>KPI'er</p> <ul> <li>Antal aktive brugere p\u00e5 platformen.</li> <li>Gennemsnitlig tid brugt p\u00e5 at designe en bane.</li> <li>Brugertilfredshedsm\u00e5linger</li> <li>Overholdelse af regler i banedesign</li> <li>Antallet af oprettede baner (x% for\u00f8gelse,i forhold til hvad der er nu)</li> <li>Aktivitet p\u00e5 oprettede baner (Kommentarer, delinger)</li> <li>En tilfredshedscore p\u00e5 8/10, laver p\u00e5 baggrund af brugerunders\u00f8gelser</li> </ul>"},{"location":"systemudvikling/#sprogbrug-i-domnet","title":"Sprogbrug i dom\u00e6net","text":"<ul> <li>Klasse: Sv\u00e6rhedsgrad / niveau for en bane</li> <li>\u00d8velse/Momenter: Det som hunden skal udf\u00f8re. Det kan v\u00e6re et spring, st\u00e5, h\u00f8jre handlet etc.</li> <li>Ekvipage: Hund og hundef\u00f8rer</li> <li>Skilt: Det skilt p\u00e5 banen, hvor der st\u00e5r angivet hvad ekvipage skal udf\u00f8re</li> <li>Rally lydighed: Hundesport</li> <li>Reglementet: De officelle regler/retningslinjer fra Landsforeningen Danmarks Civilie Hundef\u00f8rerforering, anvendes i forbindelse med konkurrence baner.</li> <li>Instrukt\u00f8r: frivillige underviser i de lokale foreninger.</li> </ul>"},{"location":"systemudvikling/#systemudviklingsmetoder","title":"Systemudviklingsmetoder","text":""},{"location":"systemudvikling/#fdd-feature-driven-development","title":"FDD - Feature Driven Development","text":"<p>Team 2 har valgt <code>Feature Driven Development</code>, ogs\u00e5 kaldet <code>FDD</code>, som den f\u00f8rste systemudviklingsmetode at arbejde ud fra.</p> <p>FDD er en agil metode, der oftest anvendes af store teams. Afg\u00f8rende for denne tilgang er oprettelsen af en liste over funktioner Feature List for at identificere projektets krav og h\u00e5ndtere opgaver relateret til udviklingen af produktet.</p> <p>Features, kan anskues som <code>Use Cases</code> i RUP <code>(Rational Unified Process)</code>, og som <code>User's stories</code> i Scrum. Disse udg\u00f8r grundlaget for projektets krav og planl\u00e6gning og udtrykkes som <code>handling-resultat-objekt</code>.</p>"},{"location":"systemudvikling/#best-practices-i-fdd","title":"Best Practices i FDD","text":"<p>Der er 8 bedste praksis <code>(best pratices)</code> som b\u00f8r benyttes n\u00e5r FDD anvendes som systemudviklingsmetode. </p> <ul> <li>Domain object modeling:<ul> <li>En overordnet dom\u00e6nemodel <code>(An overall model)</code> opbygges, der fungere som et rammev\u00e6rk og f\u00e6llesforst\u00e5elses ramme for udvikling af features.</li> <li>Se mere dokumentation af Team 2's overall model her.</li> </ul> </li> <li>Developing by feature:<ul> <li>Features-s\u00e6t bliver nedbrudt, indtil de n\u00e5r det mindste punkt, der er h\u00e5ndterbart nok til at levere resultater. Dette indb\u00e6rer at opdele de overordnede systemkrav i mindre, mere h\u00e5ndterbare features, som derefter kan fungere som de grundl\u00e6ggende opgaver <code>(Tasks)</code>, som systemet skal kunne udf\u00f8rer, og yderligere opdele dem i mindre dele, der kan udvikles individuelt.</li> <li>Se mere dokumentation af Team 2's Developing by feature her</li> </ul> </li> <li>Component/Class Ownership:<ul> <li>Ansvaret for en given feature der skal udvikles, tildeles \u00e9n udvikler eller \u00e9t udviklingsteam, som bliver holdt til ansvar for kode-konsistensen, ydeevne og integritet til det overordnede projekts m\u00e5l og krav overholders i forhold til processejeren.</li> <li>Se mere dokumentation af Team 2's Component/Class Ownership her</li> </ul> </li> <li>Feature Teams:<ul> <li>Dette er mindre udviklings grupper/teams, som dynamisk bliver formet, opl\u00f8st og formet igen, alt efter hvilke features der skal udvikles.</li> <li>Se mere dokumentation af Team 2's Feature Teams her</li> </ul> </li> <li>Inspections:<ul> <li>Indarbejd regelm\u00e6ssige inspektionsaktiviteter i udviklingsprocessen. Dette kan omfatte <code>peer reviews</code> og <code>systemgennemgang</code>. Det kan ogs\u00e5 omfatte <code>kvalitetssikringsaktiviteter</code> i udviklingsprocessen, da FDD er en <code>iterativ udviklingsmetode</code> som g\u00f8r brug af af en <code>cyklisk procesmodel</code>.</li> <li>Se mere dokumentation af Team 2's Inspections her</li> </ul> </li> <li>Configuration Management:<ul> <li>\u00c6ndringer i produktet/systemet dokumenteres og vedligeholdes til fremtidige referencer.</li> <li>Det er form\u00e5let med denne website at fungere som dokumentation af hele <code>projekt Rally Obedience</code>.</li> </ul> </li> <li>Regular Builds:<ul> <li>For at sikre produktet er relevant og brugbart, udgives mindre dele af produktet reglm\u00e6ssigt indtil hele projektet er f\u00e6rdigt.</li> <li>Disse mindre udgivelser af produktet, anvendes til reviews med PO, hvor feedback og evt. \u00e6ndringer defineres og tages i betragtning i den videre udviklingsproces.</li> </ul> </li> <li>Visibility of progress and results:<ul> <li>For at sikre at udviklingen af det f\u00e6rdige produkt er p\u00e5 rette spor, monitorerers progration i udviklingsprocessen og rapoteres.</li> <li>Se mere dokumentation af Team 2's Visibility of progress her</li> </ul> </li> </ul>"},{"location":"systemudvikling/#stages-i-fdd","title":"Stages i FDD","text":"<p>Overordnet arbejdes der i 5 faser/<code>(stages)</code> i FDD. Undervejs gennem de 5 stages anvendes de 8 best pratices. Selvom de 5 stages er listet herunder, er det vigtigt at forst\u00e5 at stages bliver genbes\u00f8gt gennem den cykliske processmodel. For hvert genbes\u00f8g dokumenteres evt. \u00e6ndringer og tilf\u00f8jelser.</p> <ul> <li>Stage 1 - Develop an overall model<ul> <li>Se mere dokumentation af Team 2's overall model her.</li> </ul> </li> <li>Stage 2 - Build a features list<ul> <li>Se mere dokumentation af Team 2's Feature List her</li> </ul> </li> <li>Stage 3 - Plan by feature<ul> <li>Se mere dokumentation af Team 2's Plan by feature her</li> </ul> </li> <li>Stage 4 - Design by feature<ul> <li>Se mere dokumentation af Team 2's Design by features</li> </ul> </li> <li>Stage 5 - Build by feature</li> </ul>"},{"location":"systemudvikling/#tilpasning-af-fdd","title":"Tilpasning af FDD","text":"<p>Team 2 har udf\u00e6rdiget artefaktorne <code>Business Case</code> og <code>Use Case Diagram</code> som supplerende v\u00e6rkt\u00f8jer til teknikken <code>Develop an overall modell</code>. For n\u00e6rmere beskrivelse af selve teknikken se Team 2's overall model her.</p>"},{"location":"systemudvikling/#reflections-on-fdd","title":"Refleksioner FDD","text":""},{"location":"systemudvikling/#refleksioner-om-arbejdet-med-fdd","title":"Refleksioner om arbejdet med FDD","text":"<p>Feature Driven Development giver en fantastisk mulighed for at arbejde p\u00e5 mindre fokuserede dele af projektet af gangen - kaldet features. Ved at fokusere p\u00e5 individuelle funktioner/features f\u00e5r udviklingsteamet bedre kontrol over processen. Dette g\u00f8r det lettere at identificere og l\u00f8se eventuelle problemer, da \u00e6ndringer ikke p\u00e5virker hele systemet p\u00e5 en gang. </p> <p>FDD fremmer en t\u00e6t kommunikation og samarbejde mellem udviklerene. Ved at arbejde t\u00e6t sammen omkring individuelle features kan alle parter bedre forst\u00e5 kravene og forventningerne.</p> <p>Set i reto-perspektiv, ville FDD nok ikke have v\u00e6ret den optimale systemudviklingsmetode for vores team. FDD egner sig bedste til store udviklingsteams, hvor opdelingen i flere mindre Teams er muligt. Selvom vi har opdelt teamet til to mindre teams af to personer, vil vi argumentere for at st\u00f8rrer teams har sine fordele.  S\u00e6rligt n\u00e5r det kommer til at s\u00f8ge ny information om en ukendt teknologi eller flere synsvinkler i forbindelse med analyse eller design. Derudover vurdere vi at FDD kr\u00e6ver udviklingsteams med en del mere erfaring end vi har, da meget af tiden i vores projekt g\u00e5r med at finde information om vores l\u00f8sning der er pr\u00e6get at ukendte teknologier. </p> <p>Denne opfattelse kan skyldes, at f\u00f8rste gang vi skulle v\u00e6lge en systemudviklingsmetode, var vi ikke introduceret til begreberne <code>Kompleksitet</code> og <code>Usikkerheder</code>.  Usikkerheder og kompleksiteter danner et grundlag for valg af procesmodel og dermed ogs\u00e5 systemudviklings metode. Da vi efterf\u00f8lgende har identificeret mange usikkerhed, s\u00e6rligt om den anvendte teknologi i projektet, ville en anden systemudviklingsmetode, m\u00e5ske have v\u00e6ret at fortr\u00e6kke som opstarts metode. Derudover ville et mere oplyst valg af procesmodel helt sikkert have bidraget positivit til projektet og gjort proaktiv projektstyring nemmere.</p> <p>Derudover blev vi ogs\u00e5 f\u00f8rst introduceret til de forskellige typer af procesmodeller efter vi havde valgt FDD, hvilket igen giver en lidt omvendt r\u00e6kkef\u00f8lge af tingene. Med dette menes, at udviklings teamet kendte til vandfald og cyklisk procesmodel i et begrenset omfang fra tidligere semestre. Hvor udviklingsteamet her p\u00e5 3.semester har tilegnet sig ny og mere viden om procesmodeller og derfor har kunne taget et mere begrundt/oplyst valg om systemudviklingsmetode nr. 2 i projektet. </p>"},{"location":"systemudvikling/#valg-af-extream-programming-xp","title":"Valg af Extream Programming - XP","text":"<p>P\u00e5 baggrund af den nye tilegnede viden, hvor et <code>projektbrief</code> f\u00f8rst defineres, derefter udf\u00f8res <code>foranalyserne</code>, hvor <code>kompleksiteter</code> og <code>usikkerheder</code> bla. defineres og samles, som grundlag for valg af procesmodel og derefter systemudviklens metode, V\u00e6lger vi i teamet at omstrukturer til en <code>Cyklisk - inkrementel</code> procesmodel og systemudviklingsmetoden <code>Extream Programmingen(XP)</code>.</p> <p>Dette g\u00f8r vi for bla. bedre at kunne h\u00e5ndtere de usikkerheder, som vi p\u00e5 nuv\u00e6rende tidspunkt i projektets-situation st\u00e5r overfor, i form af ukendt teknologi, s\u00e6rligt anvendelsen af Blazor, som vi f\u00f8rst modtager undervisning i 7 maj. Dette har ogs\u00e5 gjort det sv\u00e6rt at gennemf\u00f8rer FDD fuldkommen, da det har v\u00e6ret sv\u00e6rt at implementere en feature i <code>frontend</code> delen af projektet. Det er lykkedes, men meget tid er g\u00e5et med at finde ud af hvordan Blazor fungere.</p> <p>Teamet vurdere, at de 4 faser i XP og tilgangen om at tage en ting af gangen og v\u00e6re im\u00f8dekommende over for \u00e6ndringer passer godt ind i projektets situation, da projektet befinder sig p\u00e5 et stadie hvor der skal refactors en del. Den overordnede <code>an-overall-model</code> model fra FDD's tidlige fase, skal genbes\u00f8ges igen og med den \u00f8gede forst\u00e5else for krav og dom\u00e6net tilrettes. Derfor virker tilgangen om at tage en ting af gangen, planl\u00e6gge, kode, teste og lytte til feedback som passende i denne st\u00f8rre refaktoreriseringsproces. Som n\u00e6vnt anvendes Cyklisk - inkrementel procesmodel til dette, da tilgangen her er at v\u00e6lge en del (en eller flere sammenh\u00e6ngende features) og udvikle i fuld fidelity. N\u00e5r denne del er fuldt udviklet, v\u00e6lges der en ny del. Dette vurderes som passende i forhold til projektet-situation om at refactor hen i mode et mere fuldt implementeret produkt.</p>"},{"location":"systemudvikling/#xp-extream-programming","title":"XP - Extream Programming","text":""},{"location":"systemudvikling/#principper-i-xp","title":"Principper i XP","text":"<p>Principperne bag denne systemudviklingsmetode er kommunikation, simpelhed, feedback, mod og accept af l\u00f8bende \u00e6ndringer (respekter at XP lever).</p> <p>De 3 vigtigste principper kan beskrives s\u00e5ledes:</p> <ul> <li>Feedback:<ul> <li>Feedback indsamles/modtages ofte, der b\u00f8r ikke g\u00e5 lang tid mellem en release af produktet uden en pr\u00e6sentation af produktet for dets bruger/PO. Gennem feedback identificeres mindre fejl og mangler, som h\u00e5ndteres med det samme f\u00f8r de skaber st\u00f8rre problemer for det samlede produkt.</li> </ul> </li> <li>Assuming Simplicity:<ul> <li>XP tager en ting ad gangen. Ofte sm\u00e5 releases vurderes at v\u00e6re givende for projektet, s\u00e5 b\u00e5de klienten/kunden og udviklerne er \"attuned\" ift. udviklingen af produktet. Dette muligg\u00f8r ogs\u00e5, at det er nemmere for b\u00e5de klienter og udviklere at spotte fejl og mangler i produktet.</li> </ul> </li> <li>Embracing Change:<ul> <li>\u00c6ndringer er uundg\u00e5elige, og derfor omfavner XP-udviklere \u00e6ndringer, n\u00e5r behovet for dem opst\u00e5r, i stedet for at arbejde rundt om dem.</li> </ul> </li> </ul>"},{"location":"systemudvikling/#faser-i-xp","title":"Faser i XP","text":"<ul> <li>Planl\u00e6gning:<ul> <li>I denne periode m\u00f8des klienter og udviklere for at diskutere produktkrav, som vil blive omsat til 'brugerhistorier/user-stories'. Disse brugerhistorier konverteres til iterationer, hvor udviklere arbejder p\u00e5 specifik funktionalitet eller funktioner i produktet. Teamet forbereder ogs\u00e5 planen, opgaverne, tidsplanerne og omkostningerne for hver iteration.</li> </ul> </li> <li>Kodning:<ul> <li>I softwareudvikling mener XP, at kodning er den vigtigste proces i projektet. Forretningsm\u00e6ssigt set er dette stadiet, hvor udviklerne s\u00f8ger efter den bedst mulige l\u00f8sning p\u00e5 et problem eller krav, som er fastlagt af klienterne.</li> </ul> </li> <li>Testning:<ul> <li>Testning udf\u00f8res inden for udviklingsfasen og ikke ved dens afslutning. Produkter pr\u00e6senteres og demonstreres for kunderne, og de tester dem baseret p\u00e5 deres krav og produktets brugervenlighed.</li> </ul> </li> <li>Lytning:<ul> <li>Efter testning, og hvis kunderne rapporterer, at produktet skal forbedres, vil udviklerne arbejde ud fra de feedback, der er indhentet. Hvis klienten allerede er tilfreds med den nuv\u00e6rende prototype, vil en ny iteration begynde.</li> </ul> </li> </ul>"},{"location":"teknologi/","title":"Teknologi","text":""},{"location":"teknologi/#osi-modellen","title":"OSI modellen","text":"<p>Hvorfor er <code>OSI Modellen</code> vigtig? For en datamatiker/program\u00f8r er det vigtig at forst\u00e5 OSI-modellen, da den:</p> <ul> <li>Strukturer komplksiteten:<ul> <li>Deler netv\u00e6rksfunktioner i lag, hvilket g\u00f8r det nemmere at fejls\u00f8ge og designe netv\u00e6rk.</li> </ul> </li> <li>Standardisere Kommunikation:<ul> <li>Sikrer, at forskellige systemer og enheder kan kommunikere effektivt.</li> </ul> </li> <li>Forbedre sikkerhed:<ul> <li>Hj\u00e6lper med at identificere og afb\u00f8de sikkerhedstrusler p\u00e5 forskellige lag.</li> </ul> </li> </ul> <p>At have en grundl\u00e6ggende forst\u00e5else af OSI-modellen g\u00f8r det lettere at arbejde med netv\u00e6rksrelaterede programmeringsopgaver og forst\u00e5, hvordan data bev\u00e6ger sig gennem et netv\u00e6rk.</p> <p>OSI-modellen ogs\u00e5 kalder <code>Open Systems Interconnection Model</code>. Best\u00e5r af 7 lag. F\u00f8lgende huske regl kan anvendes: Please Do Not Throw Sausage Pizza Away</p>"},{"location":"teknologi/#osi-physical-layer","title":"Physical layer:","text":"<p>Data p\u00e5 dette lag er i form af bits 0 og 1-taller Dette lag er ansvarlig for de specifikationerne af den fysisk hardware der bliver brugt til at kommunikere over netv\u00e6rket med.</p> <p>Dette lag definere ogs\u00e5 standarden for kommunikation. Der arbejdes med tre typer af kommunikation.</p> <ul> <li>Simplex - one way only</li> <li>Half Duplex - two way, but only send or receive at a time</li> <li>Full duplex - two way, send or receive at the same time</li> </ul> <p>Eksempler p\u00e5 enheder der befinder sig i dette lag er</p> <ul> <li>Hubs</li> <li>Network interface cards</li> <li>Repeaters</li> </ul>"},{"location":"teknologi/#osi-data-link-layer","title":"Data Link Layer:","text":"<p>Bits modtaget fra det fysiske lag <code>(Physical Layer)</code> bliver transformerede til <code>frames</code> i Data Link Layer. Dette lag er ansvarligt for kommunikationen over lokale netv\u00e6rk <code>LAN - (Local Area Network)</code>. Det s\u00f8rger for at organisere data i mindre enheder kaldet frames, hvilket g\u00f8r det nemmere at h\u00e5ndtere og transmittere information effektivt.</p> <p>En af de prim\u00e6re opgaver for Data Link Layer er <code>fysisk adressering</code>, bedre kendt som <code>MAC-adresser - (Media Access Control)</code>. Hver enhed, der kan tilsluttes et netv\u00e6rk, har en unik MAC-adresse, som sikrer, at data rammer den korrekte destination. For eksempel, n\u00e5r du sender en fil fra din computer til en printer p\u00e5 det samme netv\u00e6rk, bruger Data Link Layer MAC-adresser til at identificere b\u00e5de computeren og printeren, og s\u00f8rger for, at filen bliver sendt til den rigtige enhed.</p> <p>Derudover h\u00e5ndterer Data Link Layer <code>fejlkontrol - (error control)</code> og <code>flowkontrol - (flow control)</code>. Fejlkontrol sikrer, at eventuelle fejl, der opst\u00e5r under transmissionen af data, bliver opdaget og rettet. Flowkontrol synkroniserer sendelse og modtagelse p\u00e5 netv\u00e6rket, s\u00e5 afsenderen ikke overv\u00e6lder modtageren med for mange data p\u00e5 \u00e9n gang. Dette er vigtigt for at sikre, at netv\u00e6rkstrafikken forbliver effektiv og uden tab af data.</p> <p>Som et konkret eksempel, forestil dig at du sender en stor video fra din b\u00e6rbare computer til en ven via Wi-Fi. Data Link Layer opdeler videoen i mindre frames og tilf\u00f8jer en header, der inkluderer MAC-adressen for b\u00e5de din b\u00e6rbare computer og din vens enhed. Under transmissionen overv\u00e5ger Data Link Layer for fejl, og hvis der opdages en fejl, vil den fors\u00f8ge at rette den eller anmode om genudsendelse af de korrupte frames. Samtidig s\u00f8rger flowkontrol for, at din b\u00e6rbare computer ikke sender data hurtigere, end din vens enhed kan modtage og behandle dem. Dette koordinerede samspil g\u00f8r, at videoen bliver overf\u00f8rt korrekt og effektivt.</p> <p>Protokoller p\u00e5 Data Link Layer:</p> <ul> <li>Ethernet: En af de mest anvendte teknologier til lokale netv\u00e6rks (LANs). Ethernet specificere, hvordan data skal pakkes ind i frames og adressers ved hj\u00e6lp af MAC-adresser.</li> <li>Frame Relay: En teknik til at sende data over brede netv\u00e6rk (WANs) ved at bruge et virtuelt kredsl\u00f8b.</li> <li>Token Ring. En netv\u00e6rksprotokol, hvor en token cirkulere i et ring-topologi netv\u00e6rk, og kun den enhed, der har tokenen, kan sende data.</li> <li>Fiber Distributed Data Interface (FDDI): Bruges til at overf\u00f8rer data over fiberoptiske kabler i et LAN eller MAN - (Metropolitan Area Network). Det anvender en dobbelt ring-topologi for at sikre redudans og p\u00e5lidelighed.</li> <li>Token Bus: En netv\u00e6rksprotokol, hvor en token cirkulere i en bus-topologi, hvilket giver en retf\u00e6rdig adgangsmetode til netv\u00e6rket.</li> <li>PPP (Point-to-point protocol): Bruges til at etablere en direkte forbindelse mellem to noder og overf\u00f8rer data over serielle forbindelser som telefonlinjer.</li> </ul> <p>Enheder p\u00e5 Data Link Layer:</p> <ul> <li>Briges<ul> <li>Enheder, der forbinder to eller flere netv\u00e6rk og filtrerer trafik for at reducere kollisionsdom\u00f8ner ved at segmentere netv\u00e6rket. De opererer p\u00e5 MAC-adresse niveau.</li> </ul> </li> <li>Layer 2 Switches<ul> <li>Enheder, der opererer p\u00e5 Data Link Layer og bruger MAC-adresser til at videresende data til den korrekte port. De tilbyder bedre ydeevne og sikkerhed end simple hubs.</li> </ul> </li> </ul>"},{"location":"teknologi/#osi-network-layer","title":"Network Layer","text":"<p>Network Layer er ansvarlig for flere funktioner, der sikre, at data bliver leveret fra en kilde til en destination, uanset hvor de befinder sig i et netv\u00e6rk. </p> <ul> <li>Pakkedannelse: N\u00e5r frames fra Data Link Layer n\u00e5r Network Layer, tilf\u00f8jer Network Layer en header til hver frame. Denne proces kaldes <code>indkapsling</code>. Headeren indeholder vigtig information, s\u00e5som afsenderens og modtagerens IP-adresser. N\u00e5r en fram f\u00e5r tilf\u00f8jet en Network Layer header, bliver den til en <code>pakke</code>.</li> <li>Routing: Newtwork Layer er ansvarlig for routing, hvilket betyder at bestemme den bedste vej for pakken at tage fra kilde til destinationen. Dette involvere brug af routingptotokoller som <code>OSPF - (Open Shortest Path First)</code>, <code>BGP - (Border Gateway Protocol)</code> og <code>RIP - (Routing Information Protocol)</code>. Routing g\u00f8r det muligt for data at bev\u00e6ge sig mellem forskellige netv\u00e6rk - (subnets), hvilket er essentielt for kommunikation i st\u00f8rre netv\u00e6rk, herunder internettet.</li> <li>Fragmentering og Reassembly: Newtwork Layer h\u00e5ndtere ogs\u00e5 <code>fragmentering</code> af pakker. Hvis en pakke er for stor til at blive sendt i \u00e9n enkelt frame, <code>(baseret p\u00e5 MTU - Maximum Transmission Unit)</code>, bliver den opdelt i mindre fragmenter. N\u00e5r disse fragmenter n\u00e5r destinationen, bliver de genskabt til den oprindelige pakke. Denne proces sikrer, at store m\u00e6ngder data kan transporteres effektivit over netv\u00e6rk med forskellige MTU-st\u00f8rrelser.</li> <li>Fejlh\u00e5ndtering og Diagnostik: Network layer kan ogs\u00e5 inkludere funktioner til fejlh\u00e5ndtering og diagnostik. For eksempel bruges <code>ICMP - (Internet Control Message Protocol)</code> til at sende fejlinformation og udf\u00f8re netv\u00e6rksdiagnostik som <code>Ping og Traceroute</code>.</li> </ul> <p>Som et konkret eksempel, forstil dig, at du sender en e-mail fra din computer i Danmark til en ven i USA. N\u00e5r du klikker p\u00e5 send, bliver e-mailen opdelt i dataenheder (frames) p\u00e5 Data Link Layer. N\u00e5r disse frames n\u00e5r Network Layer:</p> <ol> <li>Bliver hver frame til en pakke ved at tilf\u00f8je en header, der indeholder din IP-adresse og din vens IP-adresse.</li> <li>Netv\u00e6rksudtyr (som router) bruger denne information til at bestemme den bedste vej gennem internettet for at levere pakken til din vens computer.</li> <li>Hvis nogen af pakkerne er for store til at passere gennem et netv\u00e6rkssegment, bliver de fragmenteret i mindre stykker.</li> <li>N\u00e5r alle pakkerne n\u00e5r destinationen, bliver de rekonstrueret til den oprindelige e-mail p\u00e5 din vens computer.</li> </ol> <p>Protokoller p\u00e5 Network Layer:</p> <ul> <li>IPv4 - internet protocol version4:<ul> <li>Den mest anvendte protokol til at sende data over internettet. IPv4 bruger 32-bit adresser.</li> </ul> </li> <li>IPv6 - internet protocol version 6:<ul> <li>Efterf\u00f8lgereen til IPv4, som bruger 128-bit adresser for at h\u00e5ndtere det voksende antal internet-enheder.</li> </ul> </li> <li>ICMP - internet control message protocol<ul> <li>Bruges til fejldiagnostik og kontrol, som f.eks. at sende fejlmeddelser og udf\u00f8rer netv\u00e6rksdiagnostik <code>(Ping og Traceroute)</code>.</li> </ul> </li> <li>IPsec - internet protocol security:<ul> <li>En protokol suite, der sikrer IP-kommunikation ved at autentificere og kryptere hver IP-pakke i en datastream.</li> </ul> </li> <li>OSPF - Open shorrtest path first:<ul> <li>En routing-protokol, der bruges til at finde den bedste vej for data gennem et IP-netv\u00e6rk.</li> </ul> </li> <li>EIGRP - enhanced interior gateway routing protocol:<ul> <li>En avanceret distance-vector routing-protokol, der hj\u00e6lper med at finde den optimale rute til data.</li> </ul> </li> </ul> <p>Enheder p\u00e5 Netv\u00e6rk Layer:</p> <ul> <li>Layer 3 Switches<ul> <li>Disse enheder kan udf\u00f8rer routing-funktioner ud over almindelig switching. De kan forwarde pakker baseret p\u00e5 IP-adresser, hvilket g\u00f8r dem idelle til komplekse netv\u00e6rk.</li> </ul> </li> <li>Routers<ul> <li>Grundl\u00e6ggende enhed i et netv\u00e6rk, der bestemmer den bedste vej for at sende data mellem forskellige netv\u00e6rk baseret p\u00e5 IP-adresser.</li> </ul> </li> <li>Firewalls<ul> <li>Sikkerhedsenheder, der overv\u00e5ger og kontrollere netv\u00e6rkstrafik baseret p\u00e5 foruddefinerede sikkerhedsregler. De kan operer p\u00e5 flere lag, men typisk filtrerer de trafik baseret p\u00e5 IP-adresser og portnumre</li> </ul> </li> </ul>"},{"location":"teknologi/#osi-transport-layer","title":"Transport Layer","text":"<p>N\u00e5r pakkerne fra Newtwork Layer kommer op p\u00e5 Transport Layer, bliver der tilf\u00f8jert yderligere headers, og pakkerne bliver til <code>segments</code>. Trasport Layer er ansvarlig for en meget vigtig funktion, da det er dette lag, som definere <code>transport protocol</code>. En transportprotokol kan v\u00e6re <code>TCP</code> eller <code>UDP</code>.</p> <p>TCP (Transmission Control Protocol)</p> <ul> <li>P\u00e5lidelig og forbindelsesorienteret:<ul> <li>TCP etablere en forbindelse mellem afsender og modtager gennem <code>3-way-handshake</code>. Denne proces sikrer, at begge parter er klar til dataoverf\u00f8rsel.</li> </ul> </li> <li>Fejlkontrol, sekvensering og gendannelse:<ul> <li>TCP s\u00f8rger for, at alle segmenter ankommer korrekt ved at nummerere dem og kvittere for modtagelsen. Hvis et segment g\u00e5r tabt, bliver det sendt igen.</li> </ul> </li> <li>Flowkontrol: <ul> <li>TCP bruger mekanismer som <code>sliding window</code> for at kontrollere m\u00e6ngden af data, der sendes, f\u00f8r modtageren skal kvittere for dem. Dette forhindrer netv\u00e6rksbelastning.</li> </ul> </li> <li>Brugsscenarier<ul> <li>TCP er ideelt for applikationer, hvor dataenes integritet er kritisk, s\u00e5som webbrowsing <code>(HTTP/HTTPS)</code>, e-mail <code>(SMTP, IMAP)</code> og filoverf\u00f8rsel <code>(FTP)</code>.</li> </ul> </li> </ul> <p>UDP (User Datagram Protocol)</p> <ul> <li>Up\u00e5lidlig og forbindelsel\u00f8s:<ul> <li>UDP sender data uden at etablere en forbindelse og uden at sikre, at dataene n\u00e5r frem til destinationen.</li> </ul> </li> <li>Ingen fejlkontrol eller flowkontrol:<ul> <li>UDP implementere ingen mekanismer til at kontrollere eller rette fejl i dataene, hvilket g\u00f8r det lettere og hurtigere end TCP.</li> </ul> </li> <li>Lav overhed og hurtig transmission:<ul> <li>P\u00e5 grund af den lave overhed er UDP velegnet til applikationer, hvor hastighed er vigtigere end p\u00e5lidelighed, som f.eks. live video- og lydstreaming <code>(VoIP, IPTV)</code>, online gaming og DNS-opslag.</li> </ul> </li> <li>Pakkehpntering<ul> <li>UDP-pakker <code>(datagrammer)</code> sendes uafh\u00e6ngigt af hinanden, hvilket betyder, at de kan ankomme i en anden r\u00e6kkef\u00f8kge end de blev sendt.</li> </ul> </li> </ul> <p>Transport Layer er ogs\u00e5 ansvarlig for en vigtig funktion kaldet <code>process separation</code>. Denne funktion tillader flere programmer p\u00e5 sammen enhed at kommunikere samtidg ved hj\u00e6lp af <code>port numbers</code>. Hver applikation f\u00e5r tildelt en unik portnummer, der brugres til at identificere den specifikke applikation p\u00e5 netv\u00e6rket.</p> <ul> <li>portnumre:<ul> <li>well-known ports: Disse er portnumre fra 0 til 1023 og bruges af velkendte protojoller som <code>HTTP - Port 80</code>, <code>HTTPs - port 443</code>, <code>FTP - port 21</code> og <code>SMTP - port 25</code>.</li> <li>Registered ports: Disse porte er portnumre fra 1024 til 49151 og bruges af applikationer registreret hos <code>IANA - Internet Assigned Numbers Authority</code>. Det er en organisation der er ansvarlig for at koortinere nogle af de centrale elementer, der holder internettet k\u00f8rende.</li> <li>Dynamic/Private ports: Disse er portnumre fra 49152 til 65535 og bruges til dynamiske eller private forbindelser.</li> </ul> </li> </ul> <p>Som et konkret eksempel, forstil dig, at su streamer en live sportsbegivenhed online:</p> <ul> <li>TCP: hvis webstedet bruger TCP, sikre det, at hver del af videoen ankommer korrekt og i r\u00e6kkef\u00f8lge, men kan f\u00f8re til <code>buffering</code>, hvis netv\u00e6rket er langsomt.</li> <li>UDP: hvis webstedet bruger UDP, f\u00e5r du en j\u00e6vn streamingoplevelse uden buffering, men nogle dele af videoen kan g\u00e5 tabt, hvilket kan resultere i mindlertidige udfald eller lavere kvalitet.</li> </ul>"},{"location":"teknologi/#osi-session-layer","title":"Session Layer","text":"<p>Session Layer er ansvarlig for at etablere, administrere og afslutte sessioner mellem applikationer p\u00e5 forskellige enheder. Dette lag styrer dialogen mellem to kommunikerende enheder ved at organisere og synkronisere dataudvekslingen.</p> <p>Funktioner i Session Layer:</p> <ul> <li>Etablering af Sessioner:<ul> <li>Session Layer starter og vedligeholder kommunikationssessioner mellem applikationer p\u00e5 to forskellige computere. En session kan beskrives som en tidsbegr\u00e6nset forbindelse, hvor data kan udveksles.</li> </ul> </li> <li>Kontrol og Vedligeholdelse af Sessioner:<ul> <li>Dette lag styrer dialogen ved at fastl\u00e6gge, hvilken side der kan sende data p\u00e5 et givet tidspunkt, hvilket kaldes dialogkontrol. Det kan underst\u00f8tte b\u00e5de <code>fuld duplex (samtidig tovejskommunikation)</code> og <code>halv duplex (vekselvis tovejskommunikation)</code>.</li> </ul> </li> <li>Synkronisering:<ul> <li>Session Layer bruger synkroniseringspunkter, ogs\u00e5 kendt som <code>checkpoints</code> eller <code>synk points</code>, for at sikre, at data kan gendannes i tilf\u00e6lde af en afbrydelse. Hvis en session afbrydes, kan transmissionen genoptages fra det sidste synkroniseringspunkt i stedet for fra starten.</li> </ul> </li> <li>Sekvenskontrol:<ul> <li>Ved brug af sekvensnumre kan Session Layer spore dataenhederne og sikre, at de ankommer i den korrekte r\u00e6kkef\u00f8lge. Dette hj\u00e6lper med at organisere data, s\u00e5 applikationerne f\u00e5r den rigtige sekvens af meddelelser.</li> </ul> </li> </ul> <p>Protokoller i Session Layer:</p> <ul> <li>NetBIOS (Network Basic Input/Output System):<ul> <li>NetBIOS er en API, der giver applikationer p\u00e5 forskellige computere mulighed for at kommunikere i et <code>lokalnetv\u00e6rk (LAN)</code>. Det h\u00e5ndterer session og transporttjenester s\u00e5som navnefortolkning og datatransmission.</li> </ul> </li> <li>SOCKS (Socket Secure): <ul> <li>SOCKS er en internetprotokol, der ruter netv\u00e6rkspakker mellem klient og server gennem en <code>proxyserver</code>. Det kan bruges til at omg\u00e5 firewalls og maskere brugernes IP-adresser.</li> </ul> </li> <li>NFS (Network File System):<ul> <li>NFS tillader en computer at f\u00e5 adgang til filer over et netv\u00e6rk, som om de var p\u00e5 dens lokale diske. Session Layer h\u00e5ndterer etablering, vedligeholdelse og afslutning af filoverf\u00f8rselsessioner.</li> </ul> </li> </ul> <p>Som konkret eksempel p\u00e5 Session Layer Forestil dig, at du deltager i en online videokonference:</p> <ul> <li>Etablering af Session:<ul> <li>N\u00e5r du deltager i videokonferencen, etablerer Session Layer en session mellem din computer og serveren, der hoster konferencen.</li> </ul> </li> <li>Kontrol og Vedligeholdelse af Session:<ul> <li>Session Layer styrer, hvorn\u00e5r du kan tale og hvorn\u00e5r du kan modtage data (video og lyd), ved at styre dialogen mellem din computer og serveren.</li> </ul> </li> <li>Synkronisering:<ul> <li>Under konferencen kan synkroniseringspunkter s\u00e6ttes, s\u00e5 hvis forbindelsen afbrydes, kan sessionen genoptages fra det punkt, hvor den blev afbrudt, i stedet for at starte forfra.</li> </ul> </li> <li>Sekvenskontrol:<ul> <li>Ved brug af sekvensnumre s\u00f8rger Session Layer for, at video- og lydpakkerne ankommer i den rigtige r\u00e6kkef\u00f8lge, hvilket sikrer en korrekt og sammenh\u00e6ngende afspilning.</li> </ul> </li> </ul> <p>Session Layer spiller en kritisk rolle i netv\u00e6rkskommunikation ved at sikre, at applikationer kan opretholde en p\u00e5lidelig og organiseret forbindelse. Dette lag er is\u00e6r vigtigt i komplekse netv\u00e6rksapplikationer, hvor kontinuitet og r\u00e6kkef\u00f8lge af data er afg\u00f8rende for korrekt funktionalitet.</p>"},{"location":"teknologi/#osi-presentation-layer","title":"Presentation Layer","text":"<p>Presentation Layer er ansvarlig for datarepr\u00e6sentation, konvertering og kruptering, hvilket sikrer, at data sendes fra afsenderen i et format, som modtageren kan forst\u00e5. Dette lag fungere som et overs\u00e6tterlag mellem applikationer og netv\u00e6rk.</p> <p>Funktioner i presentation layer:</p> <ol> <li>Datarepr\u00e6sentation og Konvertering:<ul> <li>Presentation Layer h\u00e5ndtere konvertering af data mellem forskellige formater. Dette sikrer, at data kan forst\u00e5s p\u00e5 tv\u00e6rs af forskellige systmer og applikationer. Eksempler p\u00e5 dataformater inkludere:<ul> <li>ASCII - American Standard Code for Information Interchange</li> <li>EBCDIC - Extended Binary Code Decimal Interchange Code</li> <li>JPEG  Joint Photographic Experts Groups - for billeddata</li> <li>MPEG - Moving Picture Experts Group - for videodata</li> </ul> </li> </ul> </li> <li>Kryptering og Dekruptering:<ul> <li>Her sikres datasikkerhed ved at kryptere data f\u00f8r transmission og dekryptere data ved modtagelse. Kryptering beskytter data mod uautoriseret adgang under transmissionen.</li> </ul> </li> <li>Komprimering og Dekompressering:<ul> <li>Presentation Layer komprimere data for at reducere b\u00e5ndbreddeforbruget under transmission. Ved modtagelse dekomprimeres data for at gendanne deres oprindelige format. Dette er is\u00e6r nyttigt til mediefiler som billeder, video og lyd.</li> </ul> </li> </ol> <p>Som konkret eksempel: Forstil dig, at su sender en JPEG-billedefil via e-mail</p> <ol> <li>Datarepr\u00e6sentation:<ul> <li>Presentation Layer konvertere billedet til JPEG-format, som modtagerens system kan forst\u00e5.</li> </ul> </li> <li>Kryptering:<ul> <li>For at beskytte billedet under tensmissionen krypteres der.</li> </ul> </li> <li>Komprimering:<ul> <li>Billedet komprimeres for at minimere b\u00e5ndbreddeforbruget.</li> </ul> </li> <li>Dekryptering og Dekompressering:<ul> <li>Ved modtagelse dekrypteres og dekomprimeres billedet, og det konverteres tilbage til det oprindelige format for visning.</li> </ul> </li> </ol>"},{"location":"teknologi/#osi-application-layer","title":"Application Layer","text":"<p>Application Layer er det \u00f8verste lag i OSI-modellen, der fungere som gr\u00e6nsefladen mellem applikationerne og netv\u00e6rket. Det levere netv\u00e6rkstjenester direkte til applikationerne og brugerne.</p> <p>Funktioner i Application Layer:</p> <ol> <li>Netv\u00e6rkstjenester og Protokoller:<ul> <li>Application Layer tilbyder forskellige tjenester og protojoller, som tillader applikationer at kommunikere med netv\u00e6rket. Nogle almindelige protojoller inkluderer:<ul> <li>DNS - domain name system: Konverterer dom\u00e6nenavne til IP-adresser.</li> <li>HTTP - HyperText Transfer Protocol: Bruges til overf\u00f8rsel af webindhold.</li> <li>FTP - File Transfer Protocol: Bruges til filoverf\u00f8rsler mellem klient og server.</li> <li>SMTP - Simple Mail Transfer Protocol: Bruges til e-mail transmission.</li> <li>POP3/IMP: Bruges til hentning af e-mails fra en server</li> </ul> </li> </ul> </li> <li>Tjenester til Brugerapplikationer:<ul> <li>Dette lag leverer funktionalitet, som g\u00f8r det muligt for brugerapplikationer at anvende netv\u00e6rkstjenester. Det giver brugergr\u00e6nseflader <code>(GUI'er)</code> til applikationer som webbrowsere, e-mail-klienter og filoverf\u00f8rselsprogrammer.</li> </ul> </li> <li>Funktionalitet og Produktivitet:<ul> <li>Application Layer spiller en central rolle i at levere funktionalitet, produktivitet og brugervenlighed i netv\u00e6rksmilj\u00f8et. Det giver brugerne adgang til forskellige applikationer og tjenester, som de bruger til at udf\u00f8re deres opgaver.</li> </ul> </li> </ol> <p>Som konkret eksempel: N\u00e5r du bes\u00f8ger en hjemmeside ved hj\u00e6lp af en webbrowser:</p> <ol> <li>DNS: Browseren bruger DNS til at kovertere webadressen til en IP-adresse.</li> <li>HTTP: Browseren bruger HTTP til at anmode om websidens indhold fra webserveren.</li> <li>FTP: hvis du downloader en fil fra hjemmesiden, kan FTP anvendes til at overf\u00f8re filen til din computer.</li> </ol>"},{"location":"teknologi/#trusselsmodellering","title":"Trusselsmodellering","text":"<p>Trusselsmodellering er en proces, hvor potentielle trusler mod et system identificeres, forst\u00e5s og prioriteres. Denne proces hj\u00e6lper med at afd\u00e6kke sikkerhedsrisici tidligt i udviklingsprocessen, hvilket g\u00f8r det muligt at implementere passende sikkerhedsforanstaltninger. For at kunne gennemf\u00f8re en effektiv trusselsmodellering skal man forst\u00e5 systemets arkitektur og de interaktioner, der finder sted mellem dets forskellige komponenter.</p> <p>Se afsnittet overordnet arkitektur under programmering.</p>"},{"location":"teknologi/#teknologi-abuse-cases","title":"Abuse Cases baseret p\u00e5 Use Cases","text":"<p>Use cases beskriver, hvordan brugeren interagere med systemet for at opn\u00e5 et specifikt m\u00e5l. <code>Abuse Cases</code> er derimod scenarier, hvor en <code>angiber / ondsindet akt\u00f8r</code> udnytter systemet. Ved at analysere abuse cases kan systemet forbedres p\u00e5 at forsvare sig mod disse angreb.</p> <p>Eksempel p\u00e5 use case og tilf\u00f8rende abuse case:</p> <ul> <li>Use Case: En bruger ligger ind p\u00e5 systemet for at f\u00e5 adgang til sin data og se sin samling af baner.</li> <li>Abuse Case: En angriber fors\u00f8ger at logge ind ved hj\u00e6lp af brute force eller stj\u00e5lne legitimationsoplysninger.</li> </ul> <p>se afsnittet Tilf\u00f8jelse ved xp for flere eksempler p\u00e5 abuse cases til det udviklede system i projekt <code>RallyObedience</code>.</p>"},{"location":"teknologi/#teknologi-Risikoanalyse","title":"Risikoanalyse","text":"<p>Risikoanalyse involvere vurdering af sandsynligheden for forskellige trusler samt deres potentielle konsekvenser. Form\u00e5let er at prioritere trusler baseret p\u00e5 deres risiko og derefter tr\u00e6ffe beslutninger om, hvilke sikkerhedsforanstaltninger der skal implementeres.</p> <p>I system <code>RallyObedience</code> kan vi gennemf\u00f8re en risikoanalyse ved at identificere truslerne for hver use case, men ogs\u00e5 for hver komponent der indg\u00e5r i det distribuerede system og vurdere deres risiko:</p> <ol> <li> <p>Frontend (Klient - Browser med Blazor)</p> <ul> <li>Trusler: <ul> <li>Cross-Site Scripting <code>XSS</code></li> <li>Man-in-the-Middle <code>MitM</code></li> </ul> </li> <li>Sikkerhedsforanstaltninger:<ul> <li>Blazor encoder output automatisk for at beskytte mod XSS.</li> <li>Brug af HTTPS forhindre MitM angreb ved at sikre kryptering.</li> </ul> </li> </ul> </li> <li> <p>Backend (API-server)</p> <ul> <li>Trusler:<ul> <li>Denial of Service <code>Dos</code> angreb. Uatoriseret adgang, datainterception.</li> </ul> </li> <li>Sikkerhedsforanstaltninger:<ul> <li>Rate limiting for at fordinre Dos</li> <li>Authentication og Authorization for at beskytte mod uatoriseret adgang</li> <li>Kryptering af data i transit, input validering og firewalls</li> </ul> </li> </ul> </li> <li> <ul> <li>Trusler:<ul> <li>Uatoriseret adgang</li> <li><code>Datatab</code></li> <li><code>SQL-injektion</code></li> </ul> </li> <li>Sikkerhedsforanstaltninger:<ul> <li>Reglm\u00e6ssige backups for at forhindre datatab</li> <li>Adgangskontrolmekanismer (Identity)</li> <li>Brug af prepared statements eller Stored procedures for at beskytte mod SQL-injektion</li> </ul> </li> </ul> </li> </ol>"},{"location":"teknologi/#identificering-af-arbejdsprocesser-og-aktiver","title":"Identificering af Arbejdsprocesser og Aktiver","text":"<p>For at sikre en effektiv trusselmodellering og risiko analyse er det vigtigt at identificere de forskellige arbejdsprocesser og aktiver i systemet:</p> <p>arbejdsprocesser:</p> <ul> <li>Autentifikation og Autorisation: H\u00e5ndtering af brugerlogin og adgangskontrol</li> <li>Datah\u00e5ndtering: Opslag, opdatering og lagring af data</li> <li>Kommunikation: udveksling af data mellem klient og server</li> </ul> <p>Aktiver:</p> <ul> <li>Brugeroplysninger: Personlige data, loginoplysninger</li> <li>Systemdata: Bane designs, kommentarer, chatbeskeder</li> <li>Kommunikationskanaler: HTTPS-forbindelser mellem klient og server</li> <li>API-Endpoints: Funktioner til databehandling og -hentning</li> </ul>"},{"location":"teknologi/#teknologi-CIA","title":"CIA-Triaden","text":"<p>CIA-Triaden er en fundamental sikkerhedsmodel, der bruges inden for trusselsmodellering til at evaluere og sikre sytemer.  Den best\u00e5r af tre n\u00f8gleprincipper:</p> <ol> <li>Confidentiality <code>Fortrolighed</code></li> <li>Integrity <code>Integritet</code></li> <li>Availability <code>Tilg\u00e6ngelighed</code></li> </ol>"},{"location":"teknologi/#confidentiality-fortrolighed","title":"Confidentiality - Fortrolighed","text":"<p>Fortrolighed sikrer, at information kun er tilg\u00e6ngelig for autoriserede personer og systemer. Dette beskytter data mod uatoriseret adgang og afsl\u00f8ring. I trusselsmodellering handler det om at identificere og beskytte data, der kan v\u00e6re f\u00f8lsomme, s\u00e5som brugeroplysninger og kommunikation.</p> <p>Eksempler p\u00e5 sikkerhedsforanstaltninger:</p> <ul> <li>Kryptering af data i hvile og under transmission</li> <li>Implementering af adgangskontrolmekanismer som autentifikation og autorisation</li> <li>Brug af sikre kommunikationsprotokoller som HTTPS</li> </ul>"},{"location":"teknologi/#integrity-integritet","title":"Integrity - Integritet","text":"<p>Interitet sikrer, at information ikke kan \u00e6ndres eller sltees p\u00e5 en uatoriseret m\u00e5de. Det handler om at beskytte data mod manipulation og sikre, at de forbliver n\u00f8jagtige og konsistent.</p> <p>Eksempler p\u00e5 sikkerhedsforanstaltninger:</p> <ul> <li>Brug af hash-funktioner og digitale signaturer for at sikre dataintegritet.</li> <li>Implementering af input validering for at beskytte mod angrab som SQL-injektion.</li> <li>Logging og overv\u00e5gning af systemaktiviteter for at opdage og reagere p\u00e5 uatoriserede \u00e6ndringer.</li> </ul>"},{"location":"teknologi/#availability-tilgngelighed","title":"Availability - Tilg\u00e6ngelighed","text":"<p>Tilg\u00e6ngelighed sikre, at information og systmer er tilg\u00e6ngelige for autoriserede brugere, n\u00e5r de har brug for det. Dette handler om at beskytte systemet mod angreb og fejl, der kan for\u00e5rsage nedetid eller forhindre brugere i at f\u00e5 adgang til de n\u00f8dvendige ressourcer.</p> <p>Eksempler p\u00e5 sikkerhedsforantaltninger:</p> <ul> <li>Implementering af redundans og failover-mekanismer</li> <li>Beskyttelse mod DoS angreb gennem rate limiting og firewalls</li> <li>Reglm\u00e6ssige sikkerhedskopier for at sikre data tilg\u00e6ngelighed i tilf\u00e6lde af systemfejl.</li> </ul>"},{"location":"teknologi/#teknologi-STRIDE","title":"STRIDE","text":"<p><code>STRIDE</code> er en metode udviklet af Microsoft til systematisk identifikation og kategorisering af sikkerhedstrusler i software og informationssystemer.  Det st\u00e5r for seks kategorier af trusler:</p> <ol> <li>Sppofing<ul> <li>En angriver udgiver sig for at v\u00e6re en anden bruger eller en enhed for at f\u00e5 uatoriseret adgang til et system.</li> </ul> </li> <li>Tampering<ul> <li>En angriber \u00e6ndrer data eller kode i systemet, enten under transmission eller i hvile</li> </ul> </li> <li>Repudiation<ul> <li>Ogs\u00e5 kalder afvisning - En bruger n\u00e6gter at have udf\u00f8rt en handling, og systemet har ikke tilstr\u00e6kkelig beviser til at modbevise denne p\u00e5stand.</li> </ul> </li> <li>Information Discolosure<ul> <li>Uatoriseret adgang til information, der burde v\u00e6re beskyttet</li> </ul> </li> <li>Denial og Services DOS<ul> <li>Et angreb, der forhindre legitime brugere i at f\u00e5 adgang til systemet eller dets ressourcer.</li> </ul> </li> <li>Elevation of Privilege<ul> <li>En brugere opn\u00e5r h\u00f8jere adgangsrettigheder end autoriseret, hvilket giver dem mulighed for at udf\u00f8re handlinger, de normalt ikke har adgang til.</li> </ul> </li> </ol> <p>STRIDE bruges til at gennemg\u00e5 systemets forskellige dele og identificere potentielle trusler inden for hver kategori. Ved at analysere truslerne p\u00e5 denne m\u00e5de kan udviklere og sikkerhedsspecialister:</p> <ul> <li>Systematisk identificere trusler:<ul> <li>ved at anvendes STRIDE-modellen sikres det at alle relevante typer af trusler overvejes.</li> </ul> </li> <li>Forst\u00e5 truslers natur:<ul> <li>Kategoriseringen hj\u00e6lper med at forst\u00e5, hvilke type trusler systemet st\u00e5r overfor, og hvorfan de kan manifestere/opst\u00e5.</li> </ul> </li> <li>Prioritere sikkerhedsforanstaltninger / sikkerhedskrav<ul> <li>Ved at forst\u00e5 truslernes type og konsekvens kan man prioritere indsatsen p\u00e5 at beskytte systemet mod de mest alvorlige trusler.</li> </ul> </li> <li>Dokumentere sikkerhedsarbejde:<ul> <li>STRIDE-modellen giver en struktureret tilgang til at dokumentere trusselsidentifikation og de tilf\u00f8rende afb\u00f8dende foranstaltninger.</li> </ul> </li> </ul>"},{"location":"teknologi/#teknologi-containerization","title":"Containerization og Docker","text":"<p>Containerization er en teknologi, der g\u00f8r det muligt at pakke en applikation sammen med alle dens afh\u00e6ngigheder og k\u00f8re den isoleret fra andre applikationer p\u00e5 samme system. Docker er en popul\u00e6r platform til containerization, der tillader udviklere at automatisere deployment af applikarioner i letv\u00e6gtscontainere.</p>"},{"location":"teknologi/#hvorfor-containerization-er-smart","title":"Hvorfor Containerization er smart","text":"<p>Isolering of Konsistens: - Hver container k\u00f8rer isoleret fra andre, hvilket sikrer, at en applikations milj\u00f8 er ensartet uanset, hvor den k\u00f8res. Dette eliminere problemer med afh\u00e6ngigheder og <code>it works on my machine</code> - secnarier.</p> <p>Ressourceeffektivitet: - Containere dele operativsystmets kerne, hvilket g\u00f8r dem lettere og mere ressourceeffektive end traitionelle viruelle maskiner <code>(VM'er)</code>.</p> <p>Skalerbarhed: - Det er nemt at skalere applikationer ved at tilf\u00f8je flere containere baseret p\u00e5 behov. <code>Load balancing</code> og <code>orchestration</code> v\u00e6rkt\u00f8jer som Kubernetes kan bruges til at h\u00e5ndtere skalringskrav.</p> <p>Protabilitet: - Container kan k\u00f8res p\u00e5 enhver platform, der underst\u00f8tter Docker, hvilket g\u00f8r dem meget b\u00e6rbare mellem udviklings- test- og produktionsmilj\u00f8er.</p> <p>Kontinuerlig Integration og Deployment: - Docker g\u00f8r det nemt at integrere med <code>CI/CD piplines</code>, hvilket forbedrer udviklingseffektiviteten og reducerer <code>time-to-market</code>.</p>"}]}